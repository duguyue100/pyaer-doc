{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PyAER with Swig Bindings Special thanks to iniLabs for making this possible. The project is in its Alpha development stage, please submit an issue if you need our help. Design Principle Minimum installation effort Keep Python 2 and 3 in mind Clean, simple, easy to manage Well documented, human-readable code Installation 1. Install bleeding-edge libcaer dependency (RECOMMEND) $ bash < ( curl -s https://raw.githubusercontent.com/duguyue100/pyaer/master/install-libcaer.sh ) NOTE: To build libcaer on Windows, please follow this description . NOTE: For more information, see libcaer repo . NOTE: From 0.1.0a18, we support eDVS, you will need to install libserialport so that the package can work properly, follow the building instructions from here . Currently, this support is not built into the release since we are not clear how useful is this feature. If you are interested, you can build the project from scratch. 2. Directly install from pypi (RECOMMEND) $ pip install pyaer -U 3. Install from source $ git clone https://github.com/duguyue100/pyaer.git $ make install Got a Linux? libcaer relies on libusb based driver, you won't be able to access the camera unless fixing the udev rules. Refer to details at here . $ bash < ( curl -s https://raw.githubusercontent.com/duguyue100/pyaer/master/install-udev.sh )","title":"Home"},{"location":"#design-principle","text":"Minimum installation effort Keep Python 2 and 3 in mind Clean, simple, easy to manage Well documented, human-readable code","title":"Design Principle"},{"location":"#installation","text":"","title":"Installation"},{"location":"#1-install-bleeding-edge-libcaer-dependency-recommend","text":"$ bash < ( curl -s https://raw.githubusercontent.com/duguyue100/pyaer/master/install-libcaer.sh ) NOTE: To build libcaer on Windows, please follow this description . NOTE: For more information, see libcaer repo . NOTE: From 0.1.0a18, we support eDVS, you will need to install libserialport so that the package can work properly, follow the building instructions from here . Currently, this support is not built into the release since we are not clear how useful is this feature. If you are interested, you can build the project from scratch.","title":"1. Install bleeding-edge libcaer dependency (RECOMMEND)"},{"location":"#2-directly-install-from-pypi-recommend","text":"$ pip install pyaer -U","title":"2. Directly install from pypi (RECOMMEND)"},{"location":"#3-install-from-source","text":"$ git clone https://github.com/duguyue100/pyaer.git $ make install","title":"3. Install from source"},{"location":"#got-a-linux","text":"libcaer relies on libusb based driver, you won't be able to access the camera unless fixing the udev rules. Refer to details at here . $ bash < ( curl -s https://raw.githubusercontent.com/duguyue100/pyaer/master/install-udev.sh )","title":"Got a Linux?"},{"location":"davis/","text":"[source] DAVIS pyaer . davis . DAVIS ( device_id = 1 , bus_number_restrict = 0 , dev_address_restrict = 0 , serial_number = '' , noise_filter = False ) DAVIS. Arguments device_id : int a unique ID to identify the device from others. Will be used as the source for EventPackets being generate from its data. default is 1 bus_number_restrict : int restrict the search for viable devices to only this USB bus number. default is 0 dev_address_restrict : int restrict the search for viable devices to only this USB device address. default is 0 serial_number : str restrict the search for viable devices to only devices which do possess the given Serial Number in their USB SerialNumber descriptor. default is \"\" noise_filter : bool if enable noise filter. default is False [source] DAVISFX2 pyaer . davis . DAVISFX2 ( device_id = 1 , bus_number_restrict = 0 , dev_address_restrict = 0 , serial_number = '' , noise_filter = False ) DAVIS FX2. Arguments device_id : int a unique ID to identify the device from others. Will be used as the source for EventPackets being generate from its data. default is 1 bus_number_restrict : int restrict the search for viable devices to only this USB bus number. default is 0 dev_address_restrict : int restrict the search for viable devices to only this USB device address. default is 0 serial_number : str restrict the search for viable devices to only devices which do possess the given Serial Number in their USB SerialNumber descriptor. default is \"\" noise_filter : bool if enable noise filter. default is False [source] DAVISFX3 pyaer . davis . DAVISFX3 ( device_id = 1 , bus_number_restrict = 0 , dev_address_restrict = 0 , serial_number = '' , noise_filter = False ) DAVIS FX3. Arguments device_id : int a unique ID to identify the device from others. Will be used as the source for EventPackets being generate from its data. default is 1 bus_number_restrict : int restrict the search for viable devices to only this USB bus number. default is 0 dev_address_restrict : int restrict the search for viable devices to only this USB device address. default is 0 serial_number : str restrict the search for viable devices to only devices which do possess the given Serial Number in their USB SerialNumber descriptor. default is \"\" noise_filter : bool if enable noise filter. default is False [source] DAVISRPI pyaer . davis . DAVISRPI ( device_id = 1 , bus_number_restrict = 0 , dev_address_restrict = 0 , serial_number = '' , noise_filter = False ) DAVIS RPI. Arguments device_id : int a unique ID to identify the device from others. Will be used as the source for EventPackets being generate from its data. default is 1 bus_number_restrict : int restrict the search for viable devices to only this USB bus number. default is 0 dev_address_restrict : int restrict the search for viable devices to only this USB device address. default is 0 serial_number : str restrict the search for viable devices to only devices which do possess the given Serial Number in their USB SerialNumber descriptor. default is \"\" noise_filter : bool if enable noise filter. default is False obtain_device_info obtain_device_info ( handle ) Obtain DAVIS info. This function collects the following information from the device: Deveice ID Device serial number Device USB bus number Device USB device address Device string Logic version If the device is the master device Logic clock ADC clock Chip ID Camera DVS width Camera DVS height If the device has pixel filter If the device has hardware background activity filter If the device has test event generator Camera APS width Camera APS height APS color filter If the device has APS global shutter If the device has APS quad ROI If the device has APS external ADC If the device has APS internal ADC If external input has generator If external input has extra detectors If the device has DVS ROI filter If the device has DVS statistics If the device has MUX statistics Arguments handle : caerDeviceHandle a valid device handle that can be used with the other libcaer functions, or None on error. open open ( device_id = 1 , bus_number_restrict = 0 , dev_address_restrict = 0 , serial_number = '' ) Open DAVIS device. Arguments device_id : int a unique ID to identify the device from others. Will be used as the source for EventPackets being generate from its data. default is 1 bus_number_restrict : int restrict the search for viable devices to only this USB bus number. default is 0 dev_address_restrict : int restrict the search for viable devices to only this USB device address. default is 0 serial_number : str restrict the search for viable devices to only devices which do possess the given Serial Number in their USB SerialNumber descriptor. default is \"\" set_bias_from_json set_bias_from_json ( file_path , verbose = False ) Set bias from loading JSON configuration file. Arguments file_path : str absolute path of the JSON bias file. verbose : bool optional debugging message. set_cf_bias set_cf_bias ( param_addr , param , coarse , fine , mode ) Setting coarse fine bias. Arguments param_addr : int a parameter address, to select a specific parameter to update from this particular configuration module. Only positive numbers (including zero) are allowed. param : int or bool a configuration parameter's new value. coarse : int coarae value fine : int fine value mode : setting mode n_type , p_type , n_cas_type , n_off_type , p_off_type , vdac set_bias set_bias ( bias_obj ) Set bias from bias dictionary. Arguments bias_obj : dict dictionary that contains DAVIS biases. Returns flag : bool True if set successful, False otherwise. get_cf_bias get_cf_bias ( param_addr , param ) Get coarse-fine bias. Arguments param_addr : int a parameter address, to select a specific parameter to update from this particular configuration module. Only positive numbers (including zero) are allowed. param : int or bool a configuration parameter's new value. Returns coarse_value : uint coarse value fine_value : uint fine value get_bias get_bias () Get bias settings. Returns bias_obj : dict dictionary that contains DAVIS current bias settings. save_bias_to_json save_bias_to_json ( file_path ) Save bias to JSON. Arguments file_path : str the absolute path to the destiation. Returns flag : bool returns True if success in writing, False otherwise. start_data_stream start_data_stream ( send_default_config = True ) Start streaming data. Arguments send_default_config : bool send default config to the device before starting the data streaming. default is True set_noise_filter set_noise_filter ( noise_filter ) Set noise filter. Arguments noise_filter : filters.DVSNoise A valid DVSNoise object. This filter implements software-level background activity filter. enable_noise_filter enable_noise_filter () Enalbe DVS noise filter. This function enables the DVS noise filter. Note that this function will initialize a DVSNoise filter if there is None. disable_noise_filter disable_noise_filter () Disable noise filter. This method disable the noise filter. Note that this function doesn't destroy the existed noise filter. It simply switches off the function. get_polarity_event get_polarity_event ( packet_header , noise_filter = False ) Get a packet of polarity event. Arguments packet_header : caerEventPacketHeader the header that represents a event packet noise_filter : bool the background activity filter is applied if True. Returns events : numpy.ndarray a 2-D array that has the shape of (N, 4) where N is the number of events in the event packet. Each row in the array represents a single polarity event. The first number is the timestamp. The second number is the X position of the event. The third number is the Y position of the event. The fourth number represents the polarity of the event (positive or negative). If the noise_filter option is set to True , this array has an additional column at the end. The last column represents the validity of the corresponding event. Filtered events will be marked as 0. num_events : int number of the polarity events available in the packet. get_event get_event () Get Event. Returns pol_events : numpy.ndarray a 2-D array that has the shape of (N, 4) where N is the number of events in the event packet. Each row in the array represents a single polarity event. The first number is the timestamp. The second number is the X position of the event. The third number is the Y position of the event. The fourth number represents the polarity of the event (positive or negative). If the noise_filter option is set to True , this array has an additional column at the end. The last column represents the validity of the corresponding event. Filtered events will be marked as 0. num_pol_events : int number of the polarity events available in the packet. special_events : numpy.ndarray a 2-D array that has the shape of (N, 2) where N is the number of events in the event packet. Each row in the array represents a single special event. The first value is the timestamp of the event. The second value is the special event data. num_special_events : int number of the special events in the packet. frames_ts : numpy.ndarray the APS frame timestamps. frames : numpy.ndarray a 3-D array that has the shape of (N, height, width). The height and width of the APS frame is determined by the specific DAVIS device (e.g., DAVIS240 will have a 180x240 APS frame. imu_events : numpy.ndarray a 2-D array that has the shape of (N, 8) where N is the number of IMU6 events in the packet. Each row of the array consists a single IMU6 event. The first value is the timestamp of the event. The next three values are accelerations on the X, Y, and Z axes. The next three values are angular velocity on the X, Y and Z axes. The last value is the temperature in Celsius scale. num_imu_events : int number of the IMU6 events. DAVIS240C Bias Example { \"DiffBn_coarse\" : 4 , \"DiffBn_fine\" : 39 , \"ONBn_coarse\" : 6 , \"ONBn_fine\" : 200 , \"OFFBn_coarse\" : 4 , \"OFFBn_fine\" : 0 , \"APSCasEPC_coarse\" : 5 , \"APSCasEPC_fine\" : 185 , \"DiffCasBNC_coarse\" : 5 , \"DiffCasBNC_fine\" : 115 , \"APSROSFBn_coarse\" : 6 , \"APSROSFBn_fine\" : 219 , \"LocalBufBn_coarse\" : 5 , \"LocalBufBn_fine\" : 164 , \"PixInvBn_coarse\" : 5 , \"PixInvBn_fine\" : 129 , \"PrBp_coarse\" : 2 , \"PrBp_fine\" : 58 , \"PrSFBp_coarse\" : 1 , \"PrSFBp_fine\" : 33 , \"RefrBp_coarse\" : 4 , \"RefrBp_fine\" : 25 , \"AEPdBn_coarse\" : 6 , \"AEPdBn_fine\" : 91 , \"LcolTimeoutBn_coarse\" : 5 , \"LcolTimeoutBn_fine\" : 49 , \"AEPuXBp_coarse\" : 4 , \"AEPuXBp_fine\" : 80 , \"AEPuYBp_coarse\" : 7 , \"AEPuYBp_fine\" : 152 , \"IFThrBn_coarse\" : 5 , \"IFThrBn_fine\" : 255 , \"IFRefrBn_coarse\" : 5 , \"IFRefrBn_fine\" : 255 , \"PadFollBn_coarse\" : 7 , \"PadFollBn_fine\" : 215 , \"APSOverflowLevelBn_coarse\" : 6 , \"APSOverflowLevelBn_fine\" : 253 , \"BiasBuffer_coarse\" : 5 , \"BiasBuffer_fine\" : 254 , \"aps_enabled\" : true , \"dvs_enabled\" : true , \"exposure\" : 4000 , \"autoexposure\" : true , \"frame_delay\" : 0 , \"imu_enabled\" : true , \"imu_acc_scale\" : 3 , \"imu_gyro_scale\" : 3 , \"imu_low_pass_filter\" : 0 , \"noise_filter_configs\" : { \"sw_background_activity_two_levels\" : true , \"sw_background_activity_check_polarity\" : true , \"sw_background_activity_support_min\" : 2 , \"sw_background_activity_support_max\" : 8 , \"sw_background_activity_time\" : 2000 , \"sw_background_activity_enable\" : true , \"sw_refractory_period_time\" : 200 , \"sw_refractory_period_enable\" : true , \"sw_hotpixel_enable\" : true , \"sw_hotpixel_learn\" : true } } DAVIS346B Bias Example { \"ADC_RefHigh_volt\" : 24 , \"ADC_RefHigh_curr\" : 7 , \"ADC_RefLow_volt\" : 1 , \"ADC_RefLow_curr\" : 7 , \"LocalBufBn_coarse\" : 5 , \"LocalBufBn_fine\" : 164 , \"PadFollBn_coarse\" : 7 , \"PadFollBn_fine\" : 215 , \"DiffBn_coarse\" : 4 , \"DiffBn_fine\" : 39 , \"ONBn_coarse\" : 6 , \"ONBn_fine\" : 255 , \"OFFBn_coarse\" : 4 , \"OFFBn_fine\" : 0 , \"PixInvBn_coarse\" : 5 , \"PixInvBn_fine\" : 129 , \"PrBp_coarse\" : 2 , \"PrBp_fine\" : 255 , \"PrSFBp_coarse\" : 1 , \"PrSFBp_fine\" : 199 , \"RefrBp_coarse\" : 3 , \"RefrBp_fine\" : 7 , \"ReadoutBufBp_coarse\" : 6 , \"ReadoutBufBp_fine\" : 20 , \"APSROSFBn_coarse\" : 6 , \"APSROSFBn_fine\" : 219 , \"ADCCompBp_coarse\" : 5 , \"ADCCompBp_fine\" : 20 , \"COLSELLowBn_coarse\" : 0 , \"COLSELLowBn_fine\" : 1 , \"DACBufBp_coarse\" : 6 , \"DACBufBp_fine\" : 60 , \"LcolTimeoutBn_coarse\" : 5 , \"LcolTimeoutBn_fine\" : 49 , \"AEPdBn_coarse\" : 6 , \"AEPdBn_fine\" : 91 , \"AEPuXBp_coarse\" : 4 , \"AEPuXBp_fine\" : 80 , \"AEPuYBp_coarse\" : 7 , \"AEPuYBp_fine\" : 152 , \"IFRefrBn_coarse\" : 5 , \"IFRefrBn_fine\" : 255 , \"IFThrBn_coarse\" : 5 , \"IFThrBn_fine\" : 255 , \"BiasBuffer_coarse\" : 5 , \"BiasBuffer_fine\" : 254 , \"aps_enabled\" : true , \"dvs_enabled\" : true , \"exposure\" : 4000 , \"autoexposure\" : true , \"frame_delay\" : 0 , \"imu_enabled\" : true , \"imu_acc_scale\" : 3 , \"imu_gyro_scale\" : 3 , \"imu_low_pass_filter\" : 0 , \"background_activity_filter_enabled\" : false , \"background_activity_filter_time\" : 80 , \"refractory_period_enabled\" : true , \"refractory_period_time\" : 2 , \"noise_filter_configs\" : { \"sw_background_activity_two_levels\" : true , \"sw_background_activity_check_polarity\" : true , \"sw_background_activity_support_min\" : 2 , \"sw_background_activity_support_max\" : 8 , \"sw_background_activity_time\" : 2000 , \"sw_background_activity_enable\" : true , \"sw_refractory_period_time\" : 200 , \"sw_refractory_period_enable\" : true , \"sw_hotpixel_enable\" : true , \"sw_hotpixel_learn\" : true } }","title":"DAVIS"},{"location":"davis/#davis","text":"pyaer . davis . DAVIS ( device_id = 1 , bus_number_restrict = 0 , dev_address_restrict = 0 , serial_number = '' , noise_filter = False ) DAVIS. Arguments device_id : int a unique ID to identify the device from others. Will be used as the source for EventPackets being generate from its data. default is 1 bus_number_restrict : int restrict the search for viable devices to only this USB bus number. default is 0 dev_address_restrict : int restrict the search for viable devices to only this USB device address. default is 0 serial_number : str restrict the search for viable devices to only devices which do possess the given Serial Number in their USB SerialNumber descriptor. default is \"\" noise_filter : bool if enable noise filter. default is False [source]","title":"DAVIS"},{"location":"davis/#davisfx2","text":"pyaer . davis . DAVISFX2 ( device_id = 1 , bus_number_restrict = 0 , dev_address_restrict = 0 , serial_number = '' , noise_filter = False ) DAVIS FX2. Arguments device_id : int a unique ID to identify the device from others. Will be used as the source for EventPackets being generate from its data. default is 1 bus_number_restrict : int restrict the search for viable devices to only this USB bus number. default is 0 dev_address_restrict : int restrict the search for viable devices to only this USB device address. default is 0 serial_number : str restrict the search for viable devices to only devices which do possess the given Serial Number in their USB SerialNumber descriptor. default is \"\" noise_filter : bool if enable noise filter. default is False [source]","title":"DAVISFX2"},{"location":"davis/#davisfx3","text":"pyaer . davis . DAVISFX3 ( device_id = 1 , bus_number_restrict = 0 , dev_address_restrict = 0 , serial_number = '' , noise_filter = False ) DAVIS FX3. Arguments device_id : int a unique ID to identify the device from others. Will be used as the source for EventPackets being generate from its data. default is 1 bus_number_restrict : int restrict the search for viable devices to only this USB bus number. default is 0 dev_address_restrict : int restrict the search for viable devices to only this USB device address. default is 0 serial_number : str restrict the search for viable devices to only devices which do possess the given Serial Number in their USB SerialNumber descriptor. default is \"\" noise_filter : bool if enable noise filter. default is False [source]","title":"DAVISFX3"},{"location":"davis/#davisrpi","text":"pyaer . davis . DAVISRPI ( device_id = 1 , bus_number_restrict = 0 , dev_address_restrict = 0 , serial_number = '' , noise_filter = False ) DAVIS RPI. Arguments device_id : int a unique ID to identify the device from others. Will be used as the source for EventPackets being generate from its data. default is 1 bus_number_restrict : int restrict the search for viable devices to only this USB bus number. default is 0 dev_address_restrict : int restrict the search for viable devices to only this USB device address. default is 0 serial_number : str restrict the search for viable devices to only devices which do possess the given Serial Number in their USB SerialNumber descriptor. default is \"\" noise_filter : bool if enable noise filter. default is False","title":"DAVISRPI"},{"location":"davis/#obtain_device_info","text":"obtain_device_info ( handle ) Obtain DAVIS info. This function collects the following information from the device: Deveice ID Device serial number Device USB bus number Device USB device address Device string Logic version If the device is the master device Logic clock ADC clock Chip ID Camera DVS width Camera DVS height If the device has pixel filter If the device has hardware background activity filter If the device has test event generator Camera APS width Camera APS height APS color filter If the device has APS global shutter If the device has APS quad ROI If the device has APS external ADC If the device has APS internal ADC If external input has generator If external input has extra detectors If the device has DVS ROI filter If the device has DVS statistics If the device has MUX statistics Arguments handle : caerDeviceHandle a valid device handle that can be used with the other libcaer functions, or None on error.","title":"obtain_device_info"},{"location":"davis/#open","text":"open ( device_id = 1 , bus_number_restrict = 0 , dev_address_restrict = 0 , serial_number = '' ) Open DAVIS device. Arguments device_id : int a unique ID to identify the device from others. Will be used as the source for EventPackets being generate from its data. default is 1 bus_number_restrict : int restrict the search for viable devices to only this USB bus number. default is 0 dev_address_restrict : int restrict the search for viable devices to only this USB device address. default is 0 serial_number : str restrict the search for viable devices to only devices which do possess the given Serial Number in their USB SerialNumber descriptor. default is \"\"","title":"open"},{"location":"davis/#set_bias_from_json","text":"set_bias_from_json ( file_path , verbose = False ) Set bias from loading JSON configuration file. Arguments file_path : str absolute path of the JSON bias file. verbose : bool optional debugging message.","title":"set_bias_from_json"},{"location":"davis/#set_cf_bias","text":"set_cf_bias ( param_addr , param , coarse , fine , mode ) Setting coarse fine bias. Arguments param_addr : int a parameter address, to select a specific parameter to update from this particular configuration module. Only positive numbers (including zero) are allowed. param : int or bool a configuration parameter's new value. coarse : int coarae value fine : int fine value mode : setting mode n_type , p_type , n_cas_type , n_off_type , p_off_type , vdac","title":"set_cf_bias"},{"location":"davis/#set_bias","text":"set_bias ( bias_obj ) Set bias from bias dictionary. Arguments bias_obj : dict dictionary that contains DAVIS biases. Returns flag : bool True if set successful, False otherwise.","title":"set_bias"},{"location":"davis/#get_cf_bias","text":"get_cf_bias ( param_addr , param ) Get coarse-fine bias. Arguments param_addr : int a parameter address, to select a specific parameter to update from this particular configuration module. Only positive numbers (including zero) are allowed. param : int or bool a configuration parameter's new value. Returns coarse_value : uint coarse value fine_value : uint fine value","title":"get_cf_bias"},{"location":"davis/#get_bias","text":"get_bias () Get bias settings. Returns bias_obj : dict dictionary that contains DAVIS current bias settings.","title":"get_bias"},{"location":"davis/#save_bias_to_json","text":"save_bias_to_json ( file_path ) Save bias to JSON. Arguments file_path : str the absolute path to the destiation. Returns flag : bool returns True if success in writing, False otherwise.","title":"save_bias_to_json"},{"location":"davis/#start_data_stream","text":"start_data_stream ( send_default_config = True ) Start streaming data. Arguments send_default_config : bool send default config to the device before starting the data streaming. default is True","title":"start_data_stream"},{"location":"davis/#set_noise_filter","text":"set_noise_filter ( noise_filter ) Set noise filter. Arguments noise_filter : filters.DVSNoise A valid DVSNoise object. This filter implements software-level background activity filter.","title":"set_noise_filter"},{"location":"davis/#enable_noise_filter","text":"enable_noise_filter () Enalbe DVS noise filter. This function enables the DVS noise filter. Note that this function will initialize a DVSNoise filter if there is None.","title":"enable_noise_filter"},{"location":"davis/#disable_noise_filter","text":"disable_noise_filter () Disable noise filter. This method disable the noise filter. Note that this function doesn't destroy the existed noise filter. It simply switches off the function.","title":"disable_noise_filter"},{"location":"davis/#get_polarity_event","text":"get_polarity_event ( packet_header , noise_filter = False ) Get a packet of polarity event. Arguments packet_header : caerEventPacketHeader the header that represents a event packet noise_filter : bool the background activity filter is applied if True. Returns events : numpy.ndarray a 2-D array that has the shape of (N, 4) where N is the number of events in the event packet. Each row in the array represents a single polarity event. The first number is the timestamp. The second number is the X position of the event. The third number is the Y position of the event. The fourth number represents the polarity of the event (positive or negative). If the noise_filter option is set to True , this array has an additional column at the end. The last column represents the validity of the corresponding event. Filtered events will be marked as 0. num_events : int number of the polarity events available in the packet.","title":"get_polarity_event"},{"location":"davis/#get_event","text":"get_event () Get Event. Returns pol_events : numpy.ndarray a 2-D array that has the shape of (N, 4) where N is the number of events in the event packet. Each row in the array represents a single polarity event. The first number is the timestamp. The second number is the X position of the event. The third number is the Y position of the event. The fourth number represents the polarity of the event (positive or negative). If the noise_filter option is set to True , this array has an additional column at the end. The last column represents the validity of the corresponding event. Filtered events will be marked as 0. num_pol_events : int number of the polarity events available in the packet. special_events : numpy.ndarray a 2-D array that has the shape of (N, 2) where N is the number of events in the event packet. Each row in the array represents a single special event. The first value is the timestamp of the event. The second value is the special event data. num_special_events : int number of the special events in the packet. frames_ts : numpy.ndarray the APS frame timestamps. frames : numpy.ndarray a 3-D array that has the shape of (N, height, width). The height and width of the APS frame is determined by the specific DAVIS device (e.g., DAVIS240 will have a 180x240 APS frame. imu_events : numpy.ndarray a 2-D array that has the shape of (N, 8) where N is the number of IMU6 events in the packet. Each row of the array consists a single IMU6 event. The first value is the timestamp of the event. The next three values are accelerations on the X, Y, and Z axes. The next three values are angular velocity on the X, Y and Z axes. The last value is the temperature in Celsius scale. num_imu_events : int number of the IMU6 events.","title":"get_event"},{"location":"davis/#davis240c-bias-example","text":"{ \"DiffBn_coarse\" : 4 , \"DiffBn_fine\" : 39 , \"ONBn_coarse\" : 6 , \"ONBn_fine\" : 200 , \"OFFBn_coarse\" : 4 , \"OFFBn_fine\" : 0 , \"APSCasEPC_coarse\" : 5 , \"APSCasEPC_fine\" : 185 , \"DiffCasBNC_coarse\" : 5 , \"DiffCasBNC_fine\" : 115 , \"APSROSFBn_coarse\" : 6 , \"APSROSFBn_fine\" : 219 , \"LocalBufBn_coarse\" : 5 , \"LocalBufBn_fine\" : 164 , \"PixInvBn_coarse\" : 5 , \"PixInvBn_fine\" : 129 , \"PrBp_coarse\" : 2 , \"PrBp_fine\" : 58 , \"PrSFBp_coarse\" : 1 , \"PrSFBp_fine\" : 33 , \"RefrBp_coarse\" : 4 , \"RefrBp_fine\" : 25 , \"AEPdBn_coarse\" : 6 , \"AEPdBn_fine\" : 91 , \"LcolTimeoutBn_coarse\" : 5 , \"LcolTimeoutBn_fine\" : 49 , \"AEPuXBp_coarse\" : 4 , \"AEPuXBp_fine\" : 80 , \"AEPuYBp_coarse\" : 7 , \"AEPuYBp_fine\" : 152 , \"IFThrBn_coarse\" : 5 , \"IFThrBn_fine\" : 255 , \"IFRefrBn_coarse\" : 5 , \"IFRefrBn_fine\" : 255 , \"PadFollBn_coarse\" : 7 , \"PadFollBn_fine\" : 215 , \"APSOverflowLevelBn_coarse\" : 6 , \"APSOverflowLevelBn_fine\" : 253 , \"BiasBuffer_coarse\" : 5 , \"BiasBuffer_fine\" : 254 , \"aps_enabled\" : true , \"dvs_enabled\" : true , \"exposure\" : 4000 , \"autoexposure\" : true , \"frame_delay\" : 0 , \"imu_enabled\" : true , \"imu_acc_scale\" : 3 , \"imu_gyro_scale\" : 3 , \"imu_low_pass_filter\" : 0 , \"noise_filter_configs\" : { \"sw_background_activity_two_levels\" : true , \"sw_background_activity_check_polarity\" : true , \"sw_background_activity_support_min\" : 2 , \"sw_background_activity_support_max\" : 8 , \"sw_background_activity_time\" : 2000 , \"sw_background_activity_enable\" : true , \"sw_refractory_period_time\" : 200 , \"sw_refractory_period_enable\" : true , \"sw_hotpixel_enable\" : true , \"sw_hotpixel_learn\" : true } }","title":"DAVIS240C Bias Example"},{"location":"davis/#davis346b-bias-example","text":"{ \"ADC_RefHigh_volt\" : 24 , \"ADC_RefHigh_curr\" : 7 , \"ADC_RefLow_volt\" : 1 , \"ADC_RefLow_curr\" : 7 , \"LocalBufBn_coarse\" : 5 , \"LocalBufBn_fine\" : 164 , \"PadFollBn_coarse\" : 7 , \"PadFollBn_fine\" : 215 , \"DiffBn_coarse\" : 4 , \"DiffBn_fine\" : 39 , \"ONBn_coarse\" : 6 , \"ONBn_fine\" : 255 , \"OFFBn_coarse\" : 4 , \"OFFBn_fine\" : 0 , \"PixInvBn_coarse\" : 5 , \"PixInvBn_fine\" : 129 , \"PrBp_coarse\" : 2 , \"PrBp_fine\" : 255 , \"PrSFBp_coarse\" : 1 , \"PrSFBp_fine\" : 199 , \"RefrBp_coarse\" : 3 , \"RefrBp_fine\" : 7 , \"ReadoutBufBp_coarse\" : 6 , \"ReadoutBufBp_fine\" : 20 , \"APSROSFBn_coarse\" : 6 , \"APSROSFBn_fine\" : 219 , \"ADCCompBp_coarse\" : 5 , \"ADCCompBp_fine\" : 20 , \"COLSELLowBn_coarse\" : 0 , \"COLSELLowBn_fine\" : 1 , \"DACBufBp_coarse\" : 6 , \"DACBufBp_fine\" : 60 , \"LcolTimeoutBn_coarse\" : 5 , \"LcolTimeoutBn_fine\" : 49 , \"AEPdBn_coarse\" : 6 , \"AEPdBn_fine\" : 91 , \"AEPuXBp_coarse\" : 4 , \"AEPuXBp_fine\" : 80 , \"AEPuYBp_coarse\" : 7 , \"AEPuYBp_fine\" : 152 , \"IFRefrBn_coarse\" : 5 , \"IFRefrBn_fine\" : 255 , \"IFThrBn_coarse\" : 5 , \"IFThrBn_fine\" : 255 , \"BiasBuffer_coarse\" : 5 , \"BiasBuffer_fine\" : 254 , \"aps_enabled\" : true , \"dvs_enabled\" : true , \"exposure\" : 4000 , \"autoexposure\" : true , \"frame_delay\" : 0 , \"imu_enabled\" : true , \"imu_acc_scale\" : 3 , \"imu_gyro_scale\" : 3 , \"imu_low_pass_filter\" : 0 , \"background_activity_filter_enabled\" : false , \"background_activity_filter_time\" : 80 , \"refractory_period_enabled\" : true , \"refractory_period_time\" : 2 , \"noise_filter_configs\" : { \"sw_background_activity_two_levels\" : true , \"sw_background_activity_check_polarity\" : true , \"sw_background_activity_support_min\" : 2 , \"sw_background_activity_support_max\" : 8 , \"sw_background_activity_time\" : 2000 , \"sw_background_activity_enable\" : true , \"sw_refractory_period_time\" : 200 , \"sw_refractory_period_enable\" : true , \"sw_hotpixel_enable\" : true , \"sw_hotpixel_learn\" : true } }","title":"DAVIS346B Bias Example"},{"location":"dvs128/","text":"[source] DVS128 pyaer . dvs128 . DVS128 ( device_id = 1 , bus_number_restrict = 0 , dev_address_restrict = 0 , serial_number = '' , noise_filter = False ) DVS128. Arguments device_id : int a unique ID to identify the device from others. Will be used as the source for EventPackets being generate from its data. default is 1 bus_number_restrict : int restrict the search for viable devices to only this USB bus number. default is 0 dev_address_restrict : int restrict the search for viable devices to only this USB device address. default is 0 serial_number : str restrict the search for viable devices to only devices which do possess the given Serial Number in their USB SerialNumber descriptor. default is \"\" noise_filter : bool if enable noise filter, default is False . obtain_device_info obtain_device_info ( handle ) Obtain DVS128 info. This function collects the following information from the device: Deveice ID If the device is a master camera Device string Device USB bus number Device USB device address Camera width Camera height Logic version Arguments handle : caerDeviceHandle a valid device handle that can be used with the other libcaer functions, or None on error. open open ( device_id = 1 , bus_number_restrict = 0 , dev_address_restrict = 0 , serial_number = '' ) Open device. Arguments device_id : int a unique ID to identify the device from others. Will be used as the source for EventPackets being generate from its data. default is 1 . bus_number_restrict : int restrict the search for viable devices to only this USB bus number. default is 0 . dev_address_restrict : int restrict the search for viable devices to only this USB device address. default is 0 . serial_number : str restrict the search for viable devices to only devices which do possess the given Serial Number in their USB SerialNumber descriptor. default is \"\" set_bias_from_json set_bias_from_json ( file_path , verbose = False ) Set bias from loading JSON configuration file. Arguments file_path : str absolute path of the JSON bias file. verbose : bool optional debugging message. set_bias set_bias ( bias_obj ) Set bias from bias dictionary. Arguments bias_obj : dict dictionary that contains DVS128 biases. Returns flag : bool True if set successful, False otherwise. get_bias get_bias () Get bias settings. Returns bias_obj : dict dictionary that contains DVS128 current bias settings. save_bias_to_json save_bias_to_json ( file_path ) Save bias to JSON. Arguments file_path : str the absolute path to the destiation. Returns flag : bool returns True if success in writing, False otherwise. start_data_stream start_data_stream ( send_default_config = True ) Start streaming data. Arguments send_default_config : bool send default config to the device before starting the data streaming. default is True set_noise_filter set_noise_filter ( noise_filter ) Set noise filter. Arguments noise_filter : filters.DVSNoise A valid DVSNoise object. This filter implements software-level background activity filter. enable_noise_filter enable_noise_filter () Enalbe DVS noise filter. This function enables the DVS noise filter. Note that this function will initialize a DVSNoise filter if there is None. disable_noise_filter disable_noise_filter () Disable noise filter. This method disable the noise filter. Note that this function doesn't destroy the existed noise filter. It simply switches off the function. get_polarity_event get_polarity_event ( packet_header , noise_filter = False ) Get a packet of polarity event. Arguments packet_header : caerEventPacketHeader the header that represents a event packet noise_filter : bool the background activity filter is applied if True. Returns events : numpy.ndarray a 2-D array that has the shape of (N, 4) where N is the number of events in the event packet. Each row in the array represents a single polarity event. The first number is the timestamp. The second number is the X position of the event. The third number is the Y position of the event. The fourth number represents the polarity of the event (positive or negative). If the noise_filter option is set to True , this array has an additional column at the end. The last column represents the validity of the corresponding event. Filtered events will be marked as 0. num_events : int number of the polarity events available in the packet. get_event get_event () Get event. Returns pol_events : numpy.ndarray a 2-D array that has the shape of (N, 4) where N is the number of events in the event packet. Each row in the array represents a single polarity event. The first number is the timestamp. The second number is the X position of the event. The third number is the Y position of the event. The fourth number represents the polarity of the event (positive or negative). If the noise_filter option is set to True , this array has an additional column at the end. The last column represents the validity of the corresponding event. Filtered events will be marked as 0. num_pol_events : int number of the polarity events available in the packet. special_events : numpy.ndarray a 2-D array that has the shape of (N, 2) where N is the number of events in the event packet. Each row in the array represents a single special event. The first value is the timestamp of the event. The second value is the special event data. num_special_events : int number of the special events in the packet. Bias Example { \"cas\" : 54 , \"injGnd\" : 1108364 , \"reqPd\" : 16777215 , \"puX\" : 8159221 , \"diffOff\" : 132 , \"req\" : 159147 , \"refr\" : 6 , \"puY\" : 16777215 , \"diffOn\" : 482443 , \"diff\" : 30153 , \"foll\" : 51 , \"Pr\" : 3 , \"noise_filter_configs\" : { \"sw_background_activity_two_levels\" : true , \"sw_background_activity_check_polarity\" : true , \"sw_background_activity_support_min\" : 2 , \"sw_background_activity_support_max\" : 8 , \"sw_background_activity_time\" : 2000 , \"sw_background_activity_enable\" : true , \"sw_refractory_period_time\" : 200 , \"sw_refractory_period_enable\" : true , \"sw_hotpixel_enable\" : true , \"sw_hotpixel_learn\" : true } }","title":"DVS128"},{"location":"dvs128/#dvs128","text":"pyaer . dvs128 . DVS128 ( device_id = 1 , bus_number_restrict = 0 , dev_address_restrict = 0 , serial_number = '' , noise_filter = False ) DVS128. Arguments device_id : int a unique ID to identify the device from others. Will be used as the source for EventPackets being generate from its data. default is 1 bus_number_restrict : int restrict the search for viable devices to only this USB bus number. default is 0 dev_address_restrict : int restrict the search for viable devices to only this USB device address. default is 0 serial_number : str restrict the search for viable devices to only devices which do possess the given Serial Number in their USB SerialNumber descriptor. default is \"\" noise_filter : bool if enable noise filter, default is False .","title":"DVS128"},{"location":"dvs128/#obtain_device_info","text":"obtain_device_info ( handle ) Obtain DVS128 info. This function collects the following information from the device: Deveice ID If the device is a master camera Device string Device USB bus number Device USB device address Camera width Camera height Logic version Arguments handle : caerDeviceHandle a valid device handle that can be used with the other libcaer functions, or None on error.","title":"obtain_device_info"},{"location":"dvs128/#open","text":"open ( device_id = 1 , bus_number_restrict = 0 , dev_address_restrict = 0 , serial_number = '' ) Open device. Arguments device_id : int a unique ID to identify the device from others. Will be used as the source for EventPackets being generate from its data. default is 1 . bus_number_restrict : int restrict the search for viable devices to only this USB bus number. default is 0 . dev_address_restrict : int restrict the search for viable devices to only this USB device address. default is 0 . serial_number : str restrict the search for viable devices to only devices which do possess the given Serial Number in their USB SerialNumber descriptor. default is \"\"","title":"open"},{"location":"dvs128/#set_bias_from_json","text":"set_bias_from_json ( file_path , verbose = False ) Set bias from loading JSON configuration file. Arguments file_path : str absolute path of the JSON bias file. verbose : bool optional debugging message.","title":"set_bias_from_json"},{"location":"dvs128/#set_bias","text":"set_bias ( bias_obj ) Set bias from bias dictionary. Arguments bias_obj : dict dictionary that contains DVS128 biases. Returns flag : bool True if set successful, False otherwise.","title":"set_bias"},{"location":"dvs128/#get_bias","text":"get_bias () Get bias settings. Returns bias_obj : dict dictionary that contains DVS128 current bias settings.","title":"get_bias"},{"location":"dvs128/#save_bias_to_json","text":"save_bias_to_json ( file_path ) Save bias to JSON. Arguments file_path : str the absolute path to the destiation. Returns flag : bool returns True if success in writing, False otherwise.","title":"save_bias_to_json"},{"location":"dvs128/#start_data_stream","text":"start_data_stream ( send_default_config = True ) Start streaming data. Arguments send_default_config : bool send default config to the device before starting the data streaming. default is True","title":"start_data_stream"},{"location":"dvs128/#set_noise_filter","text":"set_noise_filter ( noise_filter ) Set noise filter. Arguments noise_filter : filters.DVSNoise A valid DVSNoise object. This filter implements software-level background activity filter.","title":"set_noise_filter"},{"location":"dvs128/#enable_noise_filter","text":"enable_noise_filter () Enalbe DVS noise filter. This function enables the DVS noise filter. Note that this function will initialize a DVSNoise filter if there is None.","title":"enable_noise_filter"},{"location":"dvs128/#disable_noise_filter","text":"disable_noise_filter () Disable noise filter. This method disable the noise filter. Note that this function doesn't destroy the existed noise filter. It simply switches off the function.","title":"disable_noise_filter"},{"location":"dvs128/#get_polarity_event","text":"get_polarity_event ( packet_header , noise_filter = False ) Get a packet of polarity event. Arguments packet_header : caerEventPacketHeader the header that represents a event packet noise_filter : bool the background activity filter is applied if True. Returns events : numpy.ndarray a 2-D array that has the shape of (N, 4) where N is the number of events in the event packet. Each row in the array represents a single polarity event. The first number is the timestamp. The second number is the X position of the event. The third number is the Y position of the event. The fourth number represents the polarity of the event (positive or negative). If the noise_filter option is set to True , this array has an additional column at the end. The last column represents the validity of the corresponding event. Filtered events will be marked as 0. num_events : int number of the polarity events available in the packet.","title":"get_polarity_event"},{"location":"dvs128/#get_event","text":"get_event () Get event. Returns pol_events : numpy.ndarray a 2-D array that has the shape of (N, 4) where N is the number of events in the event packet. Each row in the array represents a single polarity event. The first number is the timestamp. The second number is the X position of the event. The third number is the Y position of the event. The fourth number represents the polarity of the event (positive or negative). If the noise_filter option is set to True , this array has an additional column at the end. The last column represents the validity of the corresponding event. Filtered events will be marked as 0. num_pol_events : int number of the polarity events available in the packet. special_events : numpy.ndarray a 2-D array that has the shape of (N, 2) where N is the number of events in the event packet. Each row in the array represents a single special event. The first value is the timestamp of the event. The second value is the special event data. num_special_events : int number of the special events in the packet.","title":"get_event"},{"location":"dvs128/#bias-example","text":"{ \"cas\" : 54 , \"injGnd\" : 1108364 , \"reqPd\" : 16777215 , \"puX\" : 8159221 , \"diffOff\" : 132 , \"req\" : 159147 , \"refr\" : 6 , \"puY\" : 16777215 , \"diffOn\" : 482443 , \"diff\" : 30153 , \"foll\" : 51 , \"Pr\" : 3 , \"noise_filter_configs\" : { \"sw_background_activity_two_levels\" : true , \"sw_background_activity_check_polarity\" : true , \"sw_background_activity_support_min\" : 2 , \"sw_background_activity_support_max\" : 8 , \"sw_background_activity_time\" : 2000 , \"sw_background_activity_enable\" : true , \"sw_refractory_period_time\" : 200 , \"sw_refractory_period_enable\" : true , \"sw_hotpixel_enable\" : true , \"sw_hotpixel_learn\" : true } }","title":"Bias Example"},{"location":"dynapse/","text":"[source] DYNAPSE pyaer . dynapse . DYNAPSE ( device_id = 1 , bus_number_restrict = 0 , dev_address_restrict = 0 , serial_number = '' ) DYNAPSE. Arguments device_id : int a unique ID to identify the device from others. Will be used as the source for EventPackets being generate from its data. default is 1 bus_number_restrict : int restrict the search for viable devices to only this USB bus number. default is 0 dev_address_restrict : int restrict the search for viable devices to only this USB device address. default is 0 serial_number : str restrict the search for viable devices to only devices which do possess the given Serial Number in their USB SerialNumber descriptor. default is \"\" obtain_device_info obtain_device_info ( handle ) Obtain DYNAPSE info. This function collects the following information from the device: Deveice ID Device serial number Device USB bus number Device USB device address Device string Logic version If the device is a master camera Chip ID If the device has AER statistics If the device has MUX statistics Arguments handle : caerDeviceHandle a valid device handle that can be used with the other libcaer functions, or None on error. open open ( device_id = 1 , bus_number_restrict = 0 , dev_address_restrict = 0 , serial_number = '' ) Open device. Arguments device_id : int a unique ID to identify the device from others. Will be used as the source for EventPackets being generate from its data. default is 1 bus_number_restrict : int restrict the search for viable devices to only this USB bus number. default is 0 dev_address_restrict : int restrict the search for viable devices to only this USB device address. default is 0 serial_number : str restrict the search for viable devices to only devices which do possess the given Serial Number in their USB SerialNumber descriptor. default is \"\" set_bias_from_json set_bias_from_json ( file_path , fpga_bias = True , clear_sram = False , setup_sram = False , scope = 'all' , verbose = False ) Set bias from loading JSON configuration file. Arguments file_path : str absolute path of the JSON bias file. fpga_bias : bool Set FPGA biases if True, False otherwise, default is True clear_sram : bool Clear SRAM if True, False otherwise, Default is False setup_sram : bool Setup SRAM if True, False otherwise, default is False scope : str, dict a dictionary that describe the bias setting profile, set everything if the argument is \"all\" Here is a basic template for scope description scope = { 0: [0, 1, 2, 3], 1: [0, 1, 2, 3], 2: [0, 1, 2, 3], 3: [0, 1, 2, 3], } clear_sram clear_sram () Clear SRAM for all chips. setup_sram setup_sram () Setup SRAM for all chips. set_chip_bias set_chip_bias ( bias_obj , chip_id , core_ids = [ 0 , 1 , 2 , 3 ], clear_sram = False , setup_sram = False ) Set bias for a single chip. Arguments bias_obj : dict a dictionary that consists of all 4 core's biases chip_id : int chip id is between 0-3 core_ids : list list of core ids from 0 to 3, each element is a string, the default is [0, 1, 2, 3] e.g., - [0, 3] : set core 0 and core 3 - [2] : set core 2 - [] : do not set core level biases clear_sram : bool Clear SRAM if True, False otherwise, default is False setup_sram : bool Setup SRAM if True, False otherwise, default is False set_bias set_bias ( bias_obj , fpga_bias = True , clear_sram = False , setup_sram = False , scope = 'all' ) Set bias from bias dictionary. You don't have to turn on the clear_sram and setup_sram for reloading biases. Arguments bias_obj : dict dictionary that contains DYNAPSE biases. fpga_bias : bool Set FPGA biases if True, False otherwise, default is True clear_sram : bool Clear SRAM if True, False otherwise, default is False setup_sram : bool Setup SRAM if True, False otherwise, default is False scope : str, dict a dictionary that describe the bias setting profile, set everything if the argument is \"all\" Here is a basic template for scope description scope = { 0: [0, 1, 2, 3], 1: [0, 1, 2, 3], 2: [0, 1, 2, 3], 3: [0, 1, 2, 3], } Returns flag : bool True if set successful, False otherwise. set_fpga_bias set_fpga_bias ( bias_obj ) Set FPGA biases. Arguments bias_obj : dict dictionary that contains FPGA biases for the device. set_activity_bias set_activity_bias ( bias_obj , chip_id , core_ids = [ 0 , 1 , 2 , 3 ]) Set biases for each chip. Arguments bias_obj : dict dictionary that contains activity biases for target chip. chip_id : uint8_t one of DYNAPSE_CONFIG_DYNAPSE_U0 , DYNAPSE_CONFIG_DYNAPSE_U1 , DYNAPSE_CONFIG_DYNAPSE_U2 , DYNAPSE_CONFIG_DYNAPSE_U3 core_ids : list list of core ids from 0 to 3, each element is a int, the default is [0, 1, 2, 3] e.g., - [0, 3] : set core 0 and core 3 - [2] : set core 2 - [] : do not set core level biases get_cf_bias get_cf_bias ( param_addr , param ) Get coarse-fine bias. Note: biases for neurons currently cannot be recalled. Arguments param_addr : int a parameter address, to select a specific parameter to update from this particular configuration module. Only positive numbers (including zero) are allowed. param : int or bool a configuration parameter's new value. Returns coarse_value : uint coarse value fine_value : uint fine value get_fpga_bias get_fpga_bias () Get bias settings from FPGA. Returns bias_obj : dict dictionary that contains DYNAPSE current bias settings. save_fpga_bias_to_json save_fpga_bias_to_json ( file_path ) Save FPGA bias to JSON. Only the bias from FPGA can be retrieved. Arguments file_path : str the absolute path to the destiation. Returns flag : bool returns True if success in writing, False otherwise. start_data_stream start_data_stream ( send_default_config = True ) Start streaming data. Arguments send_default_config : bool send default config to the device before starting the data streaming. default is True core_xy_to_neuron_id core_xy_to_neuron_id ( core_id , column_x , row_y ) Map core ID and column/row address to the correct chip global neuron address. Arguments core_id : uint8 the chip's core ID, range [0, 3]. column_x : uint8 the neuron's column address, range [0, 15]. row_y : uint8 the neuron's row address, range [0, 15]. Returns neuron_id : uint16 chip global neuron address core_id_to_neuron_id core_id_to_neuron_id ( core_id , neuron_id_core ) Map core ID and per-core neuron address to the correct chip global neuron address. Arguments core_id : uint8 the chip's core ID, range [0, 3]. neuron_id_core : uint8 the neuron's address within this core, range [0, 255]. Returns neuron_id : uint16 chip global neuron address. write_poisson_spikerate write_poisson_spikerate ( neuron_id , rate ) Specifies the poisson spike generator's spike rate. Arguments neuron_id : uint16 The target neuron of the poisson spike train, range [0,1023]. rate : float The rate in Hz of the spike train, this will be quantized to the nearest supported level, range [0, 4300]. Returns flag : bool True if success, False otherwise write_sram_N write_sram_N ( neuron_id , sram_id , virtual_core_id , sx , dx , sy , dy , destination_core ) Write one of the 4 SRAMs of a single neuron. Writing the SRAM means writing the destination address of where the spikes will be routed to. This works on the on-chip SRAM! Arguments neuron_id : uint16 the neuron to program, range [0, 1023] sram_id : uint8 SRAM address, range [0, 3] virtual_core_id : utin8 fake source core ID, set it to this value instead of the actual source core ID, range [0, 3]. sx : bool X direction, can be one of: [DYNAPSE_CONFIG_SRAM_DIRECTION_X_EAST, DYNAPSE_CONFIG_SRAM_DIRECTION_X_WEST] . dx : uint8 X delta, number of chips to jumps before reaching destination, range is [0, 3] sy : bool Y direction, can be one of: [DYNAPSE_CONFIG_SRAM_DIRECTION_Y_NORTH, DYNAPSE_CONFIG_SRAM_DIRECTION_Y_SOUTH] . dy : uint8 number of chips to jumps before reaching destination, range is [0, 3] destination_core : uint8 spike destination core, uses one-hot coding for the 4 cores [C3, C2, C1, C0] -> [0, 0, 0, 0] (0 decimal) no core, [1, 1, 1, 1] (15 decimal) all cores Returns flag : bool True if success, False otherwise write_cam write_cam ( input_neuron_id , neuron_id , cam_id , synapse_type ) Write a single CAM. To specify which spikes are allowed as input into a neuron. Arguments input_neuron_id : uint16 the neuron address that should be let in as input to this neuron, range [0, 1023]. neuron_id : uint16 the neuron address whose CAM should be programmed, range [0,1023]. cam_id : uint8 CAM address (synapse), each neuron has 64, range [0,63]. synapse_type : uint8 one of the four possible synaptic weights: [DYNAPSE_CONFIG_CAMTYPE_F_EXC, DYNAPSE_CONFIG_CAMTYPE_S_EXC, DYNAPSE_CONFIG_CAMTYPE_F_INH, DYNAPSE_CONFIG_CAMTYPE_S_INH]. Returns flag : bool True if success, False otherwise get_event get_event () Get Event. Returns spike_events : numpy.ndarray a 2-D array that has the shape of (N, 4) where N is the number of spike events in the packet. Each row of the array has a single spike event. The first value is the timestamp of the event. The second value is the neuron ID. The third value is the chip ID. The last value is the source core ID. num_spike_events : int the number of the spike events. Bias Example { \"mux_timestamp_reset\" : false , \"mux_force_chip_bias_enable\" : false , \"mux_drop_aer_on_transfer_stall\" : false , \"aer_ack_delay\" : 0 , \"aer_ack_extension\" : 0 , \"aer_wait_on_transfer_stall\" : false , \"aer_external_aer_control\" : false , \"chip_req_delay\" : 30 , \"chip_req_extension\" : 30 , \"usb_early_packet_delay\" : 8 , \"c0_if_buf_p_coarse\" : 3 , \"c0_if_buf_p_fine\" : 80 , \"c0_if_rfr_n_coarse\" : 3 , \"c0_if_rfr_n_fine\" : 3 , \"c0_if_nmda_n_coarse\" : 7 , \"c0_if_nmda_n_fine\" : 0 , \"c0_if_dc_p_coarse\" : 7 , \"c0_if_dc_p_fine\" : 30 , \"c0_if_tau1_coarse\" : 7 , \"c0_if_tau1_fine\" : 5 , \"c0_if_tau2_coarse\" : 6 , \"c0_if_tau2_fine\" : 100 , \"c0_if_thr_n_coarse\" : 4 , \"c0_if_thr_n_fine\" : 120 , \"c0_if_ahw_p_coarse\" : 7 , \"c0_if_ahw_p_fine\" : 0 , \"c0_if_ahtau_n_coarse\" : 7 , \"c0_if_ahtau_n_fine\" : 35 , \"c0_if_ahthr_n_coarse\" : 7 , \"c0_if_ahthr_n_fine\" : 0 , \"c0_if_casc_n_coarse\" : 7 , \"c0_if_casc_n_fine\" : 0 , \"c0_pulse_pwlk_p_coarse\" : 3 , \"c0_pulse_pwlk_p_fine\" : 106 , \"c0_ps_weight_inh_s_n_coarse\" : 7 , \"c0_ps_weight_inh_s_n_fine\" : 0 , \"c0_ps_weight_inh_f_n_coarse\" : 7 , \"c0_ps_weight_inh_f_n_fine\" : 0 , \"c0_ps_weight_exc_s_n_coarse\" : 7 , \"c0_ps_weight_exc_s_n_fine\" : 0 , \"c0_ps_weight_exc_f_n_coarse\" : 7 , \"c0_ps_weight_exc_f_n_fine\" : 0 , \"c0_npdpii_tau_s_p_coarse\" : 7 , \"c0_npdpii_tau_s_p_fine\" : 40 , \"c0_npdpii_tau_f_p_coarse\" : 7 , \"c0_npdpii_tau_f_p_fine\" : 0 , \"c0_npdpii_thr_s_p_coarse\" : 7 , \"c0_npdpii_thr_s_p_fine\" : 40 , \"c0_npdpii_thr_f_p_coarse\" : 7 , \"c0_npdpii_thr_f_p_fine\" : 0 , \"c0_npdpie_tau_s_p_coarse\" : 7 , \"c0_npdpie_tau_s_p_fine\" : 0 , \"c0_npdpie_tau_f_p_coarse\" : 7 , \"c0_npdpie_tau_f_p_fine\" : 40 , \"c0_npdpie_thr_s_p_coarse\" : 7 , \"c0_npdpie_thr_s_p_fine\" : 0 , \"c0_npdpie_thr_f_p_coarse\" : 7 , \"c0_npdpie_thr_f_p_fine\" : 0 , \"c0_r2r_p_coarse\" : 4 , \"c0_r2r_p_fine\" : 85 , \"c1_if_buf_p_coarse\" : 3 , \"c1_if_buf_p_fine\" : 80 , \"c1_if_rfr_n_coarse\" : 3 , \"c1_if_rfr_n_fine\" : 3 , \"c1_if_nmda_n_coarse\" : 7 , \"c1_if_nmda_n_fine\" : 0 , \"c1_if_dc_p_coarse\" : 7 , \"c1_if_dc_p_fine\" : 30 , \"c1_if_tau1_coarse\" : 0 , \"c1_if_tau1_fine\" : 5 , \"c1_if_tau2_coarse\" : 6 , \"c1_if_tau2_fine\" : 100 , \"c1_if_thr_n_coarse\" : 4 , \"c1_if_thr_n_fine\" : 120 , \"c1_if_ahw_p_coarse\" : 7 , \"c1_if_ahw_p_fine\" : 0 , \"c1_if_ahtau_n_coarse\" : 7 , \"c1_if_ahtau_n_fine\" : 35 , \"c1_if_ahthr_n_coarse\" : 7 , \"c1_if_ahthr_n_fine\" : 0 , \"c1_if_casc_n_coarse\" : 7 , \"c1_if_casc_n_fine\" : 0 , \"c1_pulse_pwlk_p_coarse\" : 3 , \"c1_pulse_pwlk_p_fine\" : 106 , \"c1_ps_weight_inh_s_n_coarse\" : 7 , \"c1_ps_weight_inh_s_n_fine\" : 0 , \"c1_ps_weight_inh_f_n_coarse\" : 7 , \"c1_ps_weight_inh_f_n_fine\" : 0 , \"c1_ps_weight_exc_s_n_coarse\" : 7 , \"c1_ps_weight_exc_s_n_fine\" : 0 , \"c1_ps_weight_exc_f_n_coarse\" : 7 , \"c1_ps_weight_exc_f_n_fine\" : 0 , \"c1_npdpii_tau_s_p_coarse\" : 7 , \"c1_npdpii_tau_s_p_fine\" : 40 , \"c1_npdpii_tau_f_p_coarse\" : 7 , \"c1_npdpii_tau_f_p_fine\" : 0 , \"c1_npdpii_thr_s_p_coarse\" : 7 , \"c1_npdpii_thr_s_p_fine\" : 40 , \"c1_npdpii_thr_f_p_coarse\" : 7 , \"c1_npdpii_thr_f_p_fine\" : 0 , \"c1_npdpie_tau_s_p_coarse\" : 7 , \"c1_npdpie_tau_s_p_fine\" : 0 , \"c1_npdpie_tau_f_p_coarse\" : 7 , \"c1_npdpie_tau_f_p_fine\" : 40 , \"c1_npdpie_thr_s_p_coarse\" : 7 , \"c1_npdpie_thr_s_p_fine\" : 0 , \"c1_npdpie_thr_f_p_coarse\" : 7 , \"c1_npdpie_thr_f_p_fine\" : 0 , \"c1_r2r_p_coarse\" : 4 , \"c1_r2r_p_fine\" : 85 , \"c2_if_buf_p_coarse\" : 3 , \"c2_if_buf_p_fine\" : 80 , \"c2_if_rfr_n_coarse\" : 3 , \"c2_if_rfr_n_fine\" : 3 , \"c2_if_nmda_n_coarse\" : 7 , \"c2_if_nmda_n_fine\" : 0 , \"c2_if_dc_p_coarse\" : 7 , \"c2_if_dc_p_fine\" : 30 , \"c2_if_tau1_coarse\" : 0 , \"c2_if_tau1_fine\" : 5 , \"c2_if_tau2_coarse\" : 6 , \"c2_if_tau2_fine\" : 100 , \"c2_if_thr_n_coarse\" : 4 , \"c2_if_thr_n_fine\" : 120 , \"c2_if_ahw_p_coarse\" : 7 , \"c2_if_ahw_p_fine\" : 0 , \"c2_if_ahtau_n_coarse\" : 7 , \"c2_if_ahtau_n_fine\" : 35 , \"c2_if_ahthr_n_coarse\" : 7 , \"c2_if_ahthr_n_fine\" : 0 , \"c2_if_casc_n_coarse\" : 7 , \"c2_if_casc_n_fine\" : 0 , \"c2_pulse_pwlk_p_coarse\" : 3 , \"c2_pulse_pwlk_p_fine\" : 106 , \"c2_ps_weight_inh_s_n_coarse\" : 7 , \"c2_ps_weight_inh_s_n_fine\" : 0 , \"c2_ps_weight_inh_f_n_coarse\" : 7 , \"c2_ps_weight_inh_f_n_fine\" : 0 , \"c2_ps_weight_exc_s_n_coarse\" : 7 , \"c2_ps_weight_exc_s_n_fine\" : 0 , \"c2_ps_weight_exc_f_n_coarse\" : 7 , \"c2_ps_weight_exc_f_n_fine\" : 0 , \"c2_npdpii_tau_s_p_coarse\" : 7 , \"c2_npdpii_tau_s_p_fine\" : 40 , \"c2_npdpii_tau_f_p_coarse\" : 7 , \"c2_npdpii_tau_f_p_fine\" : 0 , \"c2_npdpii_thr_s_p_coarse\" : 7 , \"c2_npdpii_thr_s_p_fine\" : 40 , \"c2_npdpii_thr_f_p_coarse\" : 7 , \"c2_npdpii_thr_f_p_fine\" : 0 , \"c2_npdpie_tau_s_p_coarse\" : 7 , \"c2_npdpie_tau_s_p_fine\" : 0 , \"c2_npdpie_tau_f_p_coarse\" : 7 , \"c2_npdpie_tau_f_p_fine\" : 40 , \"c2_npdpie_thr_s_p_coarse\" : 7 , \"c2_npdpie_thr_s_p_fine\" : 0 , \"c2_npdpie_thr_f_p_coarse\" : 7 , \"c2_npdpie_thr_f_p_fine\" : 0 , \"c2_r2r_p_coarse\" : 4 , \"c2_r2r_p_fine\" : 85 , \"c3_if_buf_p_coarse\" : 3 , \"c3_if_buf_p_fine\" : 80 , \"c3_if_rfr_n_coarse\" : 3 , \"c3_if_rfr_n_fine\" : 3 , \"c3_if_nmda_n_coarse\" : 7 , \"c3_if_nmda_n_fine\" : 0 , \"c3_if_dc_p_coarse\" : 7 , \"c3_if_dc_p_fine\" : 30 , \"c3_if_tau1_coarse\" : 0 , \"c3_if_tau1_fine\" : 5 , \"c3_if_tau2_coarse\" : 6 , \"c3_if_tau2_fine\" : 100 , \"c3_if_thr_n_coarse\" : 4 , \"c3_if_thr_n_fine\" : 120 , \"c3_if_ahw_p_coarse\" : 7 , \"c3_if_ahw_p_fine\" : 0 , \"c3_if_ahtau_n_coarse\" : 7 , \"c3_if_ahtau_n_fine\" : 35 , \"c3_if_ahthr_n_coarse\" : 7 , \"c3_if_ahthr_n_fine\" : 0 , \"c3_if_casc_n_coarse\" : 7 , \"c3_if_casc_n_fine\" : 0 , \"c3_pulse_pwlk_p_coarse\" : 3 , \"c3_pulse_pwlk_p_fine\" : 106 , \"c3_ps_weight_inh_s_n_coarse\" : 7 , \"c3_ps_weight_inh_s_n_fine\" : 0 , \"c3_ps_weight_inh_f_n_coarse\" : 7 , \"c3_ps_weight_inh_f_n_fine\" : 0 , \"c3_ps_weight_exc_s_n_coarse\" : 7 , \"c3_ps_weight_exc_s_n_fine\" : 0 , \"c3_ps_weight_exc_f_n_coarse\" : 7 , \"c3_ps_weight_exc_f_n_fine\" : 0 , \"c3_npdpii_tau_s_p_coarse\" : 7 , \"c3_npdpii_tau_s_p_fine\" : 40 , \"c3_npdpii_tau_f_p_coarse\" : 7 , \"c3_npdpii_tau_f_p_fine\" : 0 , \"c3_npdpii_thr_s_p_coarse\" : 7 , \"c3_npdpii_thr_s_p_fine\" : 40 , \"c3_npdpii_thr_f_p_coarse\" : 7 , \"c3_npdpii_thr_f_p_fine\" : 0 , \"c3_npdpie_tau_s_p_coarse\" : 7 , \"c3_npdpie_tau_s_p_fine\" : 0 , \"c3_npdpie_tau_f_p_coarse\" : 7 , \"c3_npdpie_tau_f_p_fine\" : 40 , \"c3_npdpie_thr_s_p_coarse\" : 7 , \"c3_npdpie_thr_s_p_fine\" : 0 , \"c3_npdpie_thr_f_p_coarse\" : 7 , \"c3_npdpie_thr_f_p_fine\" : 0 , \"c3_r2r_p_coarse\" : 4 , \"c3_r2r_p_fine\" : 85 , \"d_buffer_coarse\" : 1 , \"d_buffer_fine\" : 2 , \"d_ssp_coarse\" : 0 , \"d_ssp_fine\" : 7 , \"d_ssn_coarse\" : 0 , \"d_ssn_fine\" : 15 , \"u_buffer_coarse\" : 1 , \"u_buffer_fine\" : 2 , \"u_ssp_coarse\" : 0 , \"u_ssp_fine\" : 7 , \"u_ssn_coarse\" : 0 , \"u_ssn_fine\" : 15 }","title":"DYNAPSE"},{"location":"dynapse/#dynapse","text":"pyaer . dynapse . DYNAPSE ( device_id = 1 , bus_number_restrict = 0 , dev_address_restrict = 0 , serial_number = '' ) DYNAPSE. Arguments device_id : int a unique ID to identify the device from others. Will be used as the source for EventPackets being generate from its data. default is 1 bus_number_restrict : int restrict the search for viable devices to only this USB bus number. default is 0 dev_address_restrict : int restrict the search for viable devices to only this USB device address. default is 0 serial_number : str restrict the search for viable devices to only devices which do possess the given Serial Number in their USB SerialNumber descriptor. default is \"\"","title":"DYNAPSE"},{"location":"dynapse/#obtain_device_info","text":"obtain_device_info ( handle ) Obtain DYNAPSE info. This function collects the following information from the device: Deveice ID Device serial number Device USB bus number Device USB device address Device string Logic version If the device is a master camera Chip ID If the device has AER statistics If the device has MUX statistics Arguments handle : caerDeviceHandle a valid device handle that can be used with the other libcaer functions, or None on error.","title":"obtain_device_info"},{"location":"dynapse/#open","text":"open ( device_id = 1 , bus_number_restrict = 0 , dev_address_restrict = 0 , serial_number = '' ) Open device. Arguments device_id : int a unique ID to identify the device from others. Will be used as the source for EventPackets being generate from its data. default is 1 bus_number_restrict : int restrict the search for viable devices to only this USB bus number. default is 0 dev_address_restrict : int restrict the search for viable devices to only this USB device address. default is 0 serial_number : str restrict the search for viable devices to only devices which do possess the given Serial Number in their USB SerialNumber descriptor. default is \"\"","title":"open"},{"location":"dynapse/#set_bias_from_json","text":"set_bias_from_json ( file_path , fpga_bias = True , clear_sram = False , setup_sram = False , scope = 'all' , verbose = False ) Set bias from loading JSON configuration file. Arguments file_path : str absolute path of the JSON bias file. fpga_bias : bool Set FPGA biases if True, False otherwise, default is True clear_sram : bool Clear SRAM if True, False otherwise, Default is False setup_sram : bool Setup SRAM if True, False otherwise, default is False scope : str, dict a dictionary that describe the bias setting profile, set everything if the argument is \"all\" Here is a basic template for scope description scope = { 0: [0, 1, 2, 3], 1: [0, 1, 2, 3], 2: [0, 1, 2, 3], 3: [0, 1, 2, 3], }","title":"set_bias_from_json"},{"location":"dynapse/#clear_sram","text":"clear_sram () Clear SRAM for all chips.","title":"clear_sram"},{"location":"dynapse/#setup_sram","text":"setup_sram () Setup SRAM for all chips.","title":"setup_sram"},{"location":"dynapse/#set_chip_bias","text":"set_chip_bias ( bias_obj , chip_id , core_ids = [ 0 , 1 , 2 , 3 ], clear_sram = False , setup_sram = False ) Set bias for a single chip. Arguments bias_obj : dict a dictionary that consists of all 4 core's biases chip_id : int chip id is between 0-3 core_ids : list list of core ids from 0 to 3, each element is a string, the default is [0, 1, 2, 3] e.g., - [0, 3] : set core 0 and core 3 - [2] : set core 2 - [] : do not set core level biases clear_sram : bool Clear SRAM if True, False otherwise, default is False setup_sram : bool Setup SRAM if True, False otherwise, default is False","title":"set_chip_bias"},{"location":"dynapse/#set_bias","text":"set_bias ( bias_obj , fpga_bias = True , clear_sram = False , setup_sram = False , scope = 'all' ) Set bias from bias dictionary. You don't have to turn on the clear_sram and setup_sram for reloading biases. Arguments bias_obj : dict dictionary that contains DYNAPSE biases. fpga_bias : bool Set FPGA biases if True, False otherwise, default is True clear_sram : bool Clear SRAM if True, False otherwise, default is False setup_sram : bool Setup SRAM if True, False otherwise, default is False scope : str, dict a dictionary that describe the bias setting profile, set everything if the argument is \"all\" Here is a basic template for scope description scope = { 0: [0, 1, 2, 3], 1: [0, 1, 2, 3], 2: [0, 1, 2, 3], 3: [0, 1, 2, 3], } Returns flag : bool True if set successful, False otherwise.","title":"set_bias"},{"location":"dynapse/#set_fpga_bias","text":"set_fpga_bias ( bias_obj ) Set FPGA biases. Arguments bias_obj : dict dictionary that contains FPGA biases for the device.","title":"set_fpga_bias"},{"location":"dynapse/#set_activity_bias","text":"set_activity_bias ( bias_obj , chip_id , core_ids = [ 0 , 1 , 2 , 3 ]) Set biases for each chip. Arguments bias_obj : dict dictionary that contains activity biases for target chip. chip_id : uint8_t one of DYNAPSE_CONFIG_DYNAPSE_U0 , DYNAPSE_CONFIG_DYNAPSE_U1 , DYNAPSE_CONFIG_DYNAPSE_U2 , DYNAPSE_CONFIG_DYNAPSE_U3 core_ids : list list of core ids from 0 to 3, each element is a int, the default is [0, 1, 2, 3] e.g., - [0, 3] : set core 0 and core 3 - [2] : set core 2 - [] : do not set core level biases","title":"set_activity_bias"},{"location":"dynapse/#get_cf_bias","text":"get_cf_bias ( param_addr , param ) Get coarse-fine bias. Note: biases for neurons currently cannot be recalled. Arguments param_addr : int a parameter address, to select a specific parameter to update from this particular configuration module. Only positive numbers (including zero) are allowed. param : int or bool a configuration parameter's new value. Returns coarse_value : uint coarse value fine_value : uint fine value","title":"get_cf_bias"},{"location":"dynapse/#get_fpga_bias","text":"get_fpga_bias () Get bias settings from FPGA. Returns bias_obj : dict dictionary that contains DYNAPSE current bias settings.","title":"get_fpga_bias"},{"location":"dynapse/#save_fpga_bias_to_json","text":"save_fpga_bias_to_json ( file_path ) Save FPGA bias to JSON. Only the bias from FPGA can be retrieved. Arguments file_path : str the absolute path to the destiation. Returns flag : bool returns True if success in writing, False otherwise.","title":"save_fpga_bias_to_json"},{"location":"dynapse/#start_data_stream","text":"start_data_stream ( send_default_config = True ) Start streaming data. Arguments send_default_config : bool send default config to the device before starting the data streaming. default is True","title":"start_data_stream"},{"location":"dynapse/#core_xy_to_neuron_id","text":"core_xy_to_neuron_id ( core_id , column_x , row_y ) Map core ID and column/row address to the correct chip global neuron address. Arguments core_id : uint8 the chip's core ID, range [0, 3]. column_x : uint8 the neuron's column address, range [0, 15]. row_y : uint8 the neuron's row address, range [0, 15]. Returns neuron_id : uint16 chip global neuron address","title":"core_xy_to_neuron_id"},{"location":"dynapse/#core_id_to_neuron_id","text":"core_id_to_neuron_id ( core_id , neuron_id_core ) Map core ID and per-core neuron address to the correct chip global neuron address. Arguments core_id : uint8 the chip's core ID, range [0, 3]. neuron_id_core : uint8 the neuron's address within this core, range [0, 255]. Returns neuron_id : uint16 chip global neuron address.","title":"core_id_to_neuron_id"},{"location":"dynapse/#write_poisson_spikerate","text":"write_poisson_spikerate ( neuron_id , rate ) Specifies the poisson spike generator's spike rate. Arguments neuron_id : uint16 The target neuron of the poisson spike train, range [0,1023]. rate : float The rate in Hz of the spike train, this will be quantized to the nearest supported level, range [0, 4300]. Returns flag : bool True if success, False otherwise","title":"write_poisson_spikerate"},{"location":"dynapse/#write_sram_n","text":"write_sram_N ( neuron_id , sram_id , virtual_core_id , sx , dx , sy , dy , destination_core ) Write one of the 4 SRAMs of a single neuron. Writing the SRAM means writing the destination address of where the spikes will be routed to. This works on the on-chip SRAM! Arguments neuron_id : uint16 the neuron to program, range [0, 1023] sram_id : uint8 SRAM address, range [0, 3] virtual_core_id : utin8 fake source core ID, set it to this value instead of the actual source core ID, range [0, 3]. sx : bool X direction, can be one of: [DYNAPSE_CONFIG_SRAM_DIRECTION_X_EAST, DYNAPSE_CONFIG_SRAM_DIRECTION_X_WEST] . dx : uint8 X delta, number of chips to jumps before reaching destination, range is [0, 3] sy : bool Y direction, can be one of: [DYNAPSE_CONFIG_SRAM_DIRECTION_Y_NORTH, DYNAPSE_CONFIG_SRAM_DIRECTION_Y_SOUTH] . dy : uint8 number of chips to jumps before reaching destination, range is [0, 3] destination_core : uint8 spike destination core, uses one-hot coding for the 4 cores [C3, C2, C1, C0] -> [0, 0, 0, 0] (0 decimal) no core, [1, 1, 1, 1] (15 decimal) all cores Returns flag : bool True if success, False otherwise","title":"write_sram_N"},{"location":"dynapse/#write_cam","text":"write_cam ( input_neuron_id , neuron_id , cam_id , synapse_type ) Write a single CAM. To specify which spikes are allowed as input into a neuron. Arguments input_neuron_id : uint16 the neuron address that should be let in as input to this neuron, range [0, 1023]. neuron_id : uint16 the neuron address whose CAM should be programmed, range [0,1023]. cam_id : uint8 CAM address (synapse), each neuron has 64, range [0,63]. synapse_type : uint8 one of the four possible synaptic weights: [DYNAPSE_CONFIG_CAMTYPE_F_EXC, DYNAPSE_CONFIG_CAMTYPE_S_EXC, DYNAPSE_CONFIG_CAMTYPE_F_INH, DYNAPSE_CONFIG_CAMTYPE_S_INH]. Returns flag : bool True if success, False otherwise","title":"write_cam"},{"location":"dynapse/#get_event","text":"get_event () Get Event. Returns spike_events : numpy.ndarray a 2-D array that has the shape of (N, 4) where N is the number of spike events in the packet. Each row of the array has a single spike event. The first value is the timestamp of the event. The second value is the neuron ID. The third value is the chip ID. The last value is the source core ID. num_spike_events : int the number of the spike events.","title":"get_event"},{"location":"dynapse/#bias-example","text":"{ \"mux_timestamp_reset\" : false , \"mux_force_chip_bias_enable\" : false , \"mux_drop_aer_on_transfer_stall\" : false , \"aer_ack_delay\" : 0 , \"aer_ack_extension\" : 0 , \"aer_wait_on_transfer_stall\" : false , \"aer_external_aer_control\" : false , \"chip_req_delay\" : 30 , \"chip_req_extension\" : 30 , \"usb_early_packet_delay\" : 8 , \"c0_if_buf_p_coarse\" : 3 , \"c0_if_buf_p_fine\" : 80 , \"c0_if_rfr_n_coarse\" : 3 , \"c0_if_rfr_n_fine\" : 3 , \"c0_if_nmda_n_coarse\" : 7 , \"c0_if_nmda_n_fine\" : 0 , \"c0_if_dc_p_coarse\" : 7 , \"c0_if_dc_p_fine\" : 30 , \"c0_if_tau1_coarse\" : 7 , \"c0_if_tau1_fine\" : 5 , \"c0_if_tau2_coarse\" : 6 , \"c0_if_tau2_fine\" : 100 , \"c0_if_thr_n_coarse\" : 4 , \"c0_if_thr_n_fine\" : 120 , \"c0_if_ahw_p_coarse\" : 7 , \"c0_if_ahw_p_fine\" : 0 , \"c0_if_ahtau_n_coarse\" : 7 , \"c0_if_ahtau_n_fine\" : 35 , \"c0_if_ahthr_n_coarse\" : 7 , \"c0_if_ahthr_n_fine\" : 0 , \"c0_if_casc_n_coarse\" : 7 , \"c0_if_casc_n_fine\" : 0 , \"c0_pulse_pwlk_p_coarse\" : 3 , \"c0_pulse_pwlk_p_fine\" : 106 , \"c0_ps_weight_inh_s_n_coarse\" : 7 , \"c0_ps_weight_inh_s_n_fine\" : 0 , \"c0_ps_weight_inh_f_n_coarse\" : 7 , \"c0_ps_weight_inh_f_n_fine\" : 0 , \"c0_ps_weight_exc_s_n_coarse\" : 7 , \"c0_ps_weight_exc_s_n_fine\" : 0 , \"c0_ps_weight_exc_f_n_coarse\" : 7 , \"c0_ps_weight_exc_f_n_fine\" : 0 , \"c0_npdpii_tau_s_p_coarse\" : 7 , \"c0_npdpii_tau_s_p_fine\" : 40 , \"c0_npdpii_tau_f_p_coarse\" : 7 , \"c0_npdpii_tau_f_p_fine\" : 0 , \"c0_npdpii_thr_s_p_coarse\" : 7 , \"c0_npdpii_thr_s_p_fine\" : 40 , \"c0_npdpii_thr_f_p_coarse\" : 7 , \"c0_npdpii_thr_f_p_fine\" : 0 , \"c0_npdpie_tau_s_p_coarse\" : 7 , \"c0_npdpie_tau_s_p_fine\" : 0 , \"c0_npdpie_tau_f_p_coarse\" : 7 , \"c0_npdpie_tau_f_p_fine\" : 40 , \"c0_npdpie_thr_s_p_coarse\" : 7 , \"c0_npdpie_thr_s_p_fine\" : 0 , \"c0_npdpie_thr_f_p_coarse\" : 7 , \"c0_npdpie_thr_f_p_fine\" : 0 , \"c0_r2r_p_coarse\" : 4 , \"c0_r2r_p_fine\" : 85 , \"c1_if_buf_p_coarse\" : 3 , \"c1_if_buf_p_fine\" : 80 , \"c1_if_rfr_n_coarse\" : 3 , \"c1_if_rfr_n_fine\" : 3 , \"c1_if_nmda_n_coarse\" : 7 , \"c1_if_nmda_n_fine\" : 0 , \"c1_if_dc_p_coarse\" : 7 , \"c1_if_dc_p_fine\" : 30 , \"c1_if_tau1_coarse\" : 0 , \"c1_if_tau1_fine\" : 5 , \"c1_if_tau2_coarse\" : 6 , \"c1_if_tau2_fine\" : 100 , \"c1_if_thr_n_coarse\" : 4 , \"c1_if_thr_n_fine\" : 120 , \"c1_if_ahw_p_coarse\" : 7 , \"c1_if_ahw_p_fine\" : 0 , \"c1_if_ahtau_n_coarse\" : 7 , \"c1_if_ahtau_n_fine\" : 35 , \"c1_if_ahthr_n_coarse\" : 7 , \"c1_if_ahthr_n_fine\" : 0 , \"c1_if_casc_n_coarse\" : 7 , \"c1_if_casc_n_fine\" : 0 , \"c1_pulse_pwlk_p_coarse\" : 3 , \"c1_pulse_pwlk_p_fine\" : 106 , \"c1_ps_weight_inh_s_n_coarse\" : 7 , \"c1_ps_weight_inh_s_n_fine\" : 0 , \"c1_ps_weight_inh_f_n_coarse\" : 7 , \"c1_ps_weight_inh_f_n_fine\" : 0 , \"c1_ps_weight_exc_s_n_coarse\" : 7 , \"c1_ps_weight_exc_s_n_fine\" : 0 , \"c1_ps_weight_exc_f_n_coarse\" : 7 , \"c1_ps_weight_exc_f_n_fine\" : 0 , \"c1_npdpii_tau_s_p_coarse\" : 7 , \"c1_npdpii_tau_s_p_fine\" : 40 , \"c1_npdpii_tau_f_p_coarse\" : 7 , \"c1_npdpii_tau_f_p_fine\" : 0 , \"c1_npdpii_thr_s_p_coarse\" : 7 , \"c1_npdpii_thr_s_p_fine\" : 40 , \"c1_npdpii_thr_f_p_coarse\" : 7 , \"c1_npdpii_thr_f_p_fine\" : 0 , \"c1_npdpie_tau_s_p_coarse\" : 7 , \"c1_npdpie_tau_s_p_fine\" : 0 , \"c1_npdpie_tau_f_p_coarse\" : 7 , \"c1_npdpie_tau_f_p_fine\" : 40 , \"c1_npdpie_thr_s_p_coarse\" : 7 , \"c1_npdpie_thr_s_p_fine\" : 0 , \"c1_npdpie_thr_f_p_coarse\" : 7 , \"c1_npdpie_thr_f_p_fine\" : 0 , \"c1_r2r_p_coarse\" : 4 , \"c1_r2r_p_fine\" : 85 , \"c2_if_buf_p_coarse\" : 3 , \"c2_if_buf_p_fine\" : 80 , \"c2_if_rfr_n_coarse\" : 3 , \"c2_if_rfr_n_fine\" : 3 , \"c2_if_nmda_n_coarse\" : 7 , \"c2_if_nmda_n_fine\" : 0 , \"c2_if_dc_p_coarse\" : 7 , \"c2_if_dc_p_fine\" : 30 , \"c2_if_tau1_coarse\" : 0 , \"c2_if_tau1_fine\" : 5 , \"c2_if_tau2_coarse\" : 6 , \"c2_if_tau2_fine\" : 100 , \"c2_if_thr_n_coarse\" : 4 , \"c2_if_thr_n_fine\" : 120 , \"c2_if_ahw_p_coarse\" : 7 , \"c2_if_ahw_p_fine\" : 0 , \"c2_if_ahtau_n_coarse\" : 7 , \"c2_if_ahtau_n_fine\" : 35 , \"c2_if_ahthr_n_coarse\" : 7 , \"c2_if_ahthr_n_fine\" : 0 , \"c2_if_casc_n_coarse\" : 7 , \"c2_if_casc_n_fine\" : 0 , \"c2_pulse_pwlk_p_coarse\" : 3 , \"c2_pulse_pwlk_p_fine\" : 106 , \"c2_ps_weight_inh_s_n_coarse\" : 7 , \"c2_ps_weight_inh_s_n_fine\" : 0 , \"c2_ps_weight_inh_f_n_coarse\" : 7 , \"c2_ps_weight_inh_f_n_fine\" : 0 , \"c2_ps_weight_exc_s_n_coarse\" : 7 , \"c2_ps_weight_exc_s_n_fine\" : 0 , \"c2_ps_weight_exc_f_n_coarse\" : 7 , \"c2_ps_weight_exc_f_n_fine\" : 0 , \"c2_npdpii_tau_s_p_coarse\" : 7 , \"c2_npdpii_tau_s_p_fine\" : 40 , \"c2_npdpii_tau_f_p_coarse\" : 7 , \"c2_npdpii_tau_f_p_fine\" : 0 , \"c2_npdpii_thr_s_p_coarse\" : 7 , \"c2_npdpii_thr_s_p_fine\" : 40 , \"c2_npdpii_thr_f_p_coarse\" : 7 , \"c2_npdpii_thr_f_p_fine\" : 0 , \"c2_npdpie_tau_s_p_coarse\" : 7 , \"c2_npdpie_tau_s_p_fine\" : 0 , \"c2_npdpie_tau_f_p_coarse\" : 7 , \"c2_npdpie_tau_f_p_fine\" : 40 , \"c2_npdpie_thr_s_p_coarse\" : 7 , \"c2_npdpie_thr_s_p_fine\" : 0 , \"c2_npdpie_thr_f_p_coarse\" : 7 , \"c2_npdpie_thr_f_p_fine\" : 0 , \"c2_r2r_p_coarse\" : 4 , \"c2_r2r_p_fine\" : 85 , \"c3_if_buf_p_coarse\" : 3 , \"c3_if_buf_p_fine\" : 80 , \"c3_if_rfr_n_coarse\" : 3 , \"c3_if_rfr_n_fine\" : 3 , \"c3_if_nmda_n_coarse\" : 7 , \"c3_if_nmda_n_fine\" : 0 , \"c3_if_dc_p_coarse\" : 7 , \"c3_if_dc_p_fine\" : 30 , \"c3_if_tau1_coarse\" : 0 , \"c3_if_tau1_fine\" : 5 , \"c3_if_tau2_coarse\" : 6 , \"c3_if_tau2_fine\" : 100 , \"c3_if_thr_n_coarse\" : 4 , \"c3_if_thr_n_fine\" : 120 , \"c3_if_ahw_p_coarse\" : 7 , \"c3_if_ahw_p_fine\" : 0 , \"c3_if_ahtau_n_coarse\" : 7 , \"c3_if_ahtau_n_fine\" : 35 , \"c3_if_ahthr_n_coarse\" : 7 , \"c3_if_ahthr_n_fine\" : 0 , \"c3_if_casc_n_coarse\" : 7 , \"c3_if_casc_n_fine\" : 0 , \"c3_pulse_pwlk_p_coarse\" : 3 , \"c3_pulse_pwlk_p_fine\" : 106 , \"c3_ps_weight_inh_s_n_coarse\" : 7 , \"c3_ps_weight_inh_s_n_fine\" : 0 , \"c3_ps_weight_inh_f_n_coarse\" : 7 , \"c3_ps_weight_inh_f_n_fine\" : 0 , \"c3_ps_weight_exc_s_n_coarse\" : 7 , \"c3_ps_weight_exc_s_n_fine\" : 0 , \"c3_ps_weight_exc_f_n_coarse\" : 7 , \"c3_ps_weight_exc_f_n_fine\" : 0 , \"c3_npdpii_tau_s_p_coarse\" : 7 , \"c3_npdpii_tau_s_p_fine\" : 40 , \"c3_npdpii_tau_f_p_coarse\" : 7 , \"c3_npdpii_tau_f_p_fine\" : 0 , \"c3_npdpii_thr_s_p_coarse\" : 7 , \"c3_npdpii_thr_s_p_fine\" : 40 , \"c3_npdpii_thr_f_p_coarse\" : 7 , \"c3_npdpii_thr_f_p_fine\" : 0 , \"c3_npdpie_tau_s_p_coarse\" : 7 , \"c3_npdpie_tau_s_p_fine\" : 0 , \"c3_npdpie_tau_f_p_coarse\" : 7 , \"c3_npdpie_tau_f_p_fine\" : 40 , \"c3_npdpie_thr_s_p_coarse\" : 7 , \"c3_npdpie_thr_s_p_fine\" : 0 , \"c3_npdpie_thr_f_p_coarse\" : 7 , \"c3_npdpie_thr_f_p_fine\" : 0 , \"c3_r2r_p_coarse\" : 4 , \"c3_r2r_p_fine\" : 85 , \"d_buffer_coarse\" : 1 , \"d_buffer_fine\" : 2 , \"d_ssp_coarse\" : 0 , \"d_ssp_fine\" : 7 , \"d_ssn_coarse\" : 0 , \"d_ssn_fine\" : 15 , \"u_buffer_coarse\" : 1 , \"u_buffer_fine\" : 2 , \"u_ssp_coarse\" : 0 , \"u_ssp_fine\" : 7 , \"u_ssn_coarse\" : 0 , \"u_ssn_fine\" : 15 }","title":"Bias Example"},{"location":"edvs/","text":"[source] eDVS pyaer . edvs . eDVS ( device_id = 1 , serial_port_name = '/dev/ttyUSB0' , serial_baud_rate = 12000000 , noise_filter = False ) eDVS. Arguments device_id : int a unique ID to identify the device from others. Will be used as the source for EventPackets being generate from its data. default is 1 . serial_port_name : str name of the serial port device to open. default is /dev/ttyUSB0 serial_baud_rate : uint32_t baud-rate for serial port communication. default is 12M obtain_device_info obtain_device_info ( handle ) Obtain eDVS info. This function collects the following information from the device: Deveice ID Device string If the device is a master camera Camera width Camera height Arguments handle : caerDeviceHandle a valid device handle that can be used with the other libcaer functions, or None on error. open open ( device_id = 1 , serial_port_name = '/dev/ttyUSB0' , serial_baud_rate = 12000000 ) Open device. Arguments device_id : int a unique ID to identify the device from others. Will be used as the source for EventPackets being generate from its data. default is 1 . serial_port_name : str name of the serial port device to open. default is /dev/ttyUSB0 serial_baud_rate : uint32_t baud-rate for serial port communication. default is 12M set_bias_from_json set_bias_from_json ( file_path , verbose = False ) Set bias from loading JSON configuration file. Arguments file_path : str absolute path of the JSON bias file. verbose : bool optional debugging message. set_bias set_bias ( bias_obj ) Set bias from bias dictionary. Arguments bias_obj : dict dictionary that contains eDVS biases. Returns flag : bool True if set successful, False otherwise. get_bias get_bias () Get bias settings. Returns bias_obj : dict dictionary that contains eDVS current bias settings. save_bias_to_json save_bias_to_json ( file_path ) Save bias to JSON. Arguments file_path : str the absolute path to the destiation. Returns flag : bool returns True if success in writing, False otherwise. start_data_stream start_data_stream () Start streaming data. Arguments send_default_config : bool send default config to the device before starting the data streaming. default is True set_noise_filter set_noise_filter ( noise_filter ) Set noise filter. Arguments noise_filter : filters.DVSNoise A valid DVSNoise object. This filter implements software-level background activity filter. enable_noise_filter enable_noise_filter () Enalbe DVS noise filter. This function enables the DVS noise filter. Note that this function will initialize a DVSNoise filter if there is None. disable_noise_filter disable_noise_filter () Disable noise filter. This method disable the noise filter. Note that this function doesn't destroy the existed noise filter. It simply switches off the function. get_event get_event () Get event. Returns pol_events : numpy.ndarray a 2-D array that has the shape of (N, 4) where N is the number of events in the event packet. Each row in the array represents a single polarity event. The first number is the timestamp. The second number is the X position of the event. The third number is the Y position of the event. The fourth number represents the polarity of the event (positive or negative). If the noise_filter option is set to True , this array has an additional column at the end. The last column represents the validity of the corresponding event. Filtered events will be marked as 0. num_pol_events : int number of the polarity events available in the packet. special_events : numpy.ndarray a 2-D array that has the shape of (N, 2) where N is the number of events in the event packet. Each row in the array represents a single special event. The first value is the timestamp of the event. The second value is the special event data. num_special_events : int number of the special events in the packet. Bias Example { \"cas\" : 54 , \"injGnd\" : 1108364 , \"reqPd\" : 16777215 , \"puX\" : 8159221 , \"diffOff\" : 132 , \"req\" : 159147 , \"refr\" : 6 , \"puY\" : 16777215 , \"diffOn\" : 482443 , \"diff\" : 30153 , \"foll\" : 51 , \"Pr\" : 3 , \"noise_filter_configs\" : { \"sw_background_activity_two_levels\" : true , \"sw_background_activity_check_polarity\" : true , \"sw_background_activity_support_min\" : 2 , \"sw_background_activity_support_max\" : 8 , \"sw_background_activity_time\" : 2000 , \"sw_background_activity_enable\" : true , \"sw_refractory_period_time\" : 200 , \"sw_refractory_period_enable\" : true , \"sw_hotpixel_enable\" : true , \"sw_hotpixel_learn\" : true } }","title":"eDVS"},{"location":"edvs/#edvs","text":"pyaer . edvs . eDVS ( device_id = 1 , serial_port_name = '/dev/ttyUSB0' , serial_baud_rate = 12000000 , noise_filter = False ) eDVS. Arguments device_id : int a unique ID to identify the device from others. Will be used as the source for EventPackets being generate from its data. default is 1 . serial_port_name : str name of the serial port device to open. default is /dev/ttyUSB0 serial_baud_rate : uint32_t baud-rate for serial port communication. default is 12M","title":"eDVS"},{"location":"edvs/#obtain_device_info","text":"obtain_device_info ( handle ) Obtain eDVS info. This function collects the following information from the device: Deveice ID Device string If the device is a master camera Camera width Camera height Arguments handle : caerDeviceHandle a valid device handle that can be used with the other libcaer functions, or None on error.","title":"obtain_device_info"},{"location":"edvs/#open","text":"open ( device_id = 1 , serial_port_name = '/dev/ttyUSB0' , serial_baud_rate = 12000000 ) Open device. Arguments device_id : int a unique ID to identify the device from others. Will be used as the source for EventPackets being generate from its data. default is 1 . serial_port_name : str name of the serial port device to open. default is /dev/ttyUSB0 serial_baud_rate : uint32_t baud-rate for serial port communication. default is 12M","title":"open"},{"location":"edvs/#set_bias_from_json","text":"set_bias_from_json ( file_path , verbose = False ) Set bias from loading JSON configuration file. Arguments file_path : str absolute path of the JSON bias file. verbose : bool optional debugging message.","title":"set_bias_from_json"},{"location":"edvs/#set_bias","text":"set_bias ( bias_obj ) Set bias from bias dictionary. Arguments bias_obj : dict dictionary that contains eDVS biases. Returns flag : bool True if set successful, False otherwise.","title":"set_bias"},{"location":"edvs/#get_bias","text":"get_bias () Get bias settings. Returns bias_obj : dict dictionary that contains eDVS current bias settings.","title":"get_bias"},{"location":"edvs/#save_bias_to_json","text":"save_bias_to_json ( file_path ) Save bias to JSON. Arguments file_path : str the absolute path to the destiation. Returns flag : bool returns True if success in writing, False otherwise.","title":"save_bias_to_json"},{"location":"edvs/#start_data_stream","text":"start_data_stream () Start streaming data. Arguments send_default_config : bool send default config to the device before starting the data streaming. default is True","title":"start_data_stream"},{"location":"edvs/#set_noise_filter","text":"set_noise_filter ( noise_filter ) Set noise filter. Arguments noise_filter : filters.DVSNoise A valid DVSNoise object. This filter implements software-level background activity filter.","title":"set_noise_filter"},{"location":"edvs/#enable_noise_filter","text":"enable_noise_filter () Enalbe DVS noise filter. This function enables the DVS noise filter. Note that this function will initialize a DVSNoise filter if there is None.","title":"enable_noise_filter"},{"location":"edvs/#disable_noise_filter","text":"disable_noise_filter () Disable noise filter. This method disable the noise filter. Note that this function doesn't destroy the existed noise filter. It simply switches off the function.","title":"disable_noise_filter"},{"location":"edvs/#get_event","text":"get_event () Get event. Returns pol_events : numpy.ndarray a 2-D array that has the shape of (N, 4) where N is the number of events in the event packet. Each row in the array represents a single polarity event. The first number is the timestamp. The second number is the X position of the event. The third number is the Y position of the event. The fourth number represents the polarity of the event (positive or negative). If the noise_filter option is set to True , this array has an additional column at the end. The last column represents the validity of the corresponding event. Filtered events will be marked as 0. num_pol_events : int number of the polarity events available in the packet. special_events : numpy.ndarray a 2-D array that has the shape of (N, 2) where N is the number of events in the event packet. Each row in the array represents a single special event. The first value is the timestamp of the event. The second value is the special event data. num_special_events : int number of the special events in the packet.","title":"get_event"},{"location":"edvs/#bias-example","text":"{ \"cas\" : 54 , \"injGnd\" : 1108364 , \"reqPd\" : 16777215 , \"puX\" : 8159221 , \"diffOff\" : 132 , \"req\" : 159147 , \"refr\" : 6 , \"puY\" : 16777215 , \"diffOn\" : 482443 , \"diff\" : 30153 , \"foll\" : 51 , \"Pr\" : 3 , \"noise_filter_configs\" : { \"sw_background_activity_two_levels\" : true , \"sw_background_activity_check_polarity\" : true , \"sw_background_activity_support_min\" : 2 , \"sw_background_activity_support_max\" : 8 , \"sw_background_activity_time\" : 2000 , \"sw_background_activity_enable\" : true , \"sw_refractory_period_time\" : 200 , \"sw_refractory_period_enable\" : true , \"sw_hotpixel_enable\" : true , \"sw_hotpixel_learn\" : true } }","title":"Bias Example"},{"location":"filters/","text":"[source] DVSNoise pyaer . filters . DVSNoise ( size_x , size_y ) Software DVS background activity filter. Arguments size_x : uint16 maximum X axis resolution. size_y : uint16 maximum Y axis resolution. initialize initialize () Initialize. destroy destroy () Destroy DVS noise filter to free up memory. set_bias_from_json set_bias_from_json ( file_path , verbose = False ) Set bias from loading JSON configuration file. Arguments file_path : str absolute path of the JSON bias file. set_bias set_bias ( bias_obj ) Configure filter. Arguments bias_obj : dict A dictionary that contains the configuration of the filter get_bias get_bias () Export configuration. Returns bias_obj : dict A dictionary that contains the configuration of the filter save_bias_to_json save_bias_to_json ( file_path ) Save filter configuration to JSON. Arguments file_path : str the absolute path to the destiation. Returns flag : bool returns True if success in writing, False otherwise. set_config set_config ( param_addr , param ) Set configuration. Arguments param_addr : uint8 a configuration parameter address, see defines CAER_FILTER_DVS_* . param : uint64 a configuration parameter value integer. Returns flag : bool True if operation successful, false otherwise. get_config get_config ( param_addr ) Get configuration. Arguments param_addr : uint8 a configuration parameter address, see defines CAER_FILTER_DVS_* . Returns param : uint64 the value of the configuration. apply apply ( event_packet ) Apply the filter to a event_packet. Arguments event_packet : caerEventPacket the event packet to filter. Returns filtered_event_packet : caerEventPacket the filtered event packet. get_hot_pixels get_hot_pixels ()","title":"Filters"},{"location":"filters/#dvsnoise","text":"pyaer . filters . DVSNoise ( size_x , size_y ) Software DVS background activity filter. Arguments size_x : uint16 maximum X axis resolution. size_y : uint16 maximum Y axis resolution.","title":"DVSNoise"},{"location":"filters/#initialize","text":"initialize () Initialize.","title":"initialize"},{"location":"filters/#destroy","text":"destroy () Destroy DVS noise filter to free up memory.","title":"destroy"},{"location":"filters/#set_bias_from_json","text":"set_bias_from_json ( file_path , verbose = False ) Set bias from loading JSON configuration file. Arguments file_path : str absolute path of the JSON bias file.","title":"set_bias_from_json"},{"location":"filters/#set_bias","text":"set_bias ( bias_obj ) Configure filter. Arguments bias_obj : dict A dictionary that contains the configuration of the filter","title":"set_bias"},{"location":"filters/#get_bias","text":"get_bias () Export configuration. Returns bias_obj : dict A dictionary that contains the configuration of the filter","title":"get_bias"},{"location":"filters/#save_bias_to_json","text":"save_bias_to_json ( file_path ) Save filter configuration to JSON. Arguments file_path : str the absolute path to the destiation. Returns flag : bool returns True if success in writing, False otherwise.","title":"save_bias_to_json"},{"location":"filters/#set_config","text":"set_config ( param_addr , param ) Set configuration. Arguments param_addr : uint8 a configuration parameter address, see defines CAER_FILTER_DVS_* . param : uint64 a configuration parameter value integer. Returns flag : bool True if operation successful, false otherwise.","title":"set_config"},{"location":"filters/#get_config","text":"get_config ( param_addr ) Get configuration. Arguments param_addr : uint8 a configuration parameter address, see defines CAER_FILTER_DVS_* . Returns param : uint64 the value of the configuration.","title":"get_config"},{"location":"filters/#apply","text":"apply ( event_packet ) Apply the filter to a event_packet. Arguments event_packet : caerEventPacket the event packet to filter. Returns filtered_event_packet : caerEventPacket the filtered event packet.","title":"apply"},{"location":"filters/#get_hot_pixels","text":"get_hot_pixels ()","title":"get_hot_pixels"},{"location":"log/","text":"get_logger pyaer . log . get_logger ( logger_name , logger_level , stream = None ) Get a logger for the script. Using stream handler. Arguments logger_name : str the name of the logger logger_level : int the minimial level that trigger the logger. stream : data stream if None, sys.stderr will be used. Returns logger : logging.Logger return a logger to handel the logging in the script.","title":"Logging"},{"location":"log/#get_logger","text":"pyaer . log . get_logger ( logger_name , logger_level , stream = None ) Get a logger for the script. Using stream handler. Arguments logger_name : str the name of the logger logger_level : int the minimial level that trigger the logger. stream : data stream if None, sys.stderr will be used. Returns logger : logging.Logger return a logger to handel the logging in the script.","title":"get_logger"},{"location":"serial-device/","text":"[source] SerialDevice pyaer . device . SerialDevice () Base class for serial devices. The base class for devices that use the serial port. eDVS is the only current supported device in this family. open open ( device_type , device_id = 1 , serial_port_name = '/dev/ttyUSB0' , serial_baud_rate = 12000000 ) Open USB deivce. Arguments device_type : int Device type: libcaer.CAER_DEVICE_DVS128 , libcaer.CAER_DEVICE_EDVS , libcaer.CAER_DEVICE_DAVIS , libcaer.CAER_DEVICE_DAVIS_FX2 , libcaer.CAER_DEVICE_DAVIS_FX3 , libcaer.CAER_DEVICE_DAVIS_RPI , libcaer.CAER_DEVICE_DYNAPSE . device_id : int a unique ID to identify the device from others. Will be used as the source for EventPackets being generate from its data. default is 1 . serial_port_name : str name of the serial port device to open. default is /dev/ttyUSB0 serial_baud_rate : uint32_t baud-rate for serial port communication. default is 12M data_start data_start () Start data transmission. Returns flag : bool Return True if the data transmission is initialized successfully. Otherwise False . data_stop data_stop () Stop data transmission. This method stops the data transmission only. Note that this method does not destroy the respective device handle . close close () Close USB device. This method closes an opened USB device if the respective handle is not None. shutdown shutdown () Shutdown device. This method is a combination of data_stop and close . This is a preferred way of shutting down a device. send_default_config send_default_config () Send default configuration. Each type of devices has a set of default configurations (e.g. bias) that are pre-defined in the libcaer library. Note that the default configuration might not be suitable for your needs. Returns flag : bool return True if the default config is set successfully, False otherwise. set_data_exchange_blocking set_data_exchange_blocking ( exchange_blocking = True ) Set data exchange blocking. Arguments exchange_blocking : bool whether to start all the data producer modules on the device (DVS, APS, Mux, ...) automatically when starting the data transfer thread with caerDeviceDataStart() or not. If disabled, be aware you will have to start the right modules manually, which can be useful if you need precise control over which ones are running at any time. The default is True . set_config set_config ( mod_addr , param_addr , param ) Set configuration. The main function of setting configurations (e.g., bias). Arguments mod_addr : int a module address, used to specify which configuration module one wants to update. Negative addresses are used for host-side configuration, while positive addresses (including zero) are used for device-side configuration. param_addr : int a parameter address, to select a specific parameter to update from this particular configuration module. Only positive numbers (including zero) are allowed. param : int or bool a configuration parameter's new value. Returns flag : bool returns True if the config is set successfully, False otherwise. get_config get_config ( mod_addr , param_addr ) Get Configuration. Arguments mod_addr : int a module address, used to specify which configuration module one wants to update. Negative addresses are used for host-side configuration, while positive addresses (including zero) are used for device-side configuration. param_addr : int a parameter address, to select a specific parameter to update from this particular configuration module. Only positive numbers (including zero) are allowed. Returns param : int or bool a configuration parameter's new value. Returns None if the handle is not valid. get_event get_event () Get Event. This abstract method should be implemented in all derived classes. This method returns a packet of events according to the type of the sensor. get_packet_container get_packet_container () Get event packet container. Returns packet_container : caerEventPacketContainer a container that consists of event packets. packet_number : int number of event packet in the container. get_packet_header get_packet_header ( packet_container , idx ) Get a single packet header. Arguments packet_container : caerEventPacketContainer the event packet container idx : int the index of the packet header Returns packet_header : caerEventPacketHeader the header that represents a event packet packet_type : caerEventPacketType the type of the event packet get_polarity_event get_polarity_event ( packet_header ) Get a packet of polarity event. Arguments packet_header : caerEventPacketHeader the header that represents a event packet Returns events : numpy.ndarray a 2-D array that has the shape of (N, 4) where N is the number of events in the event packet. Each row in the array represents a single polarity event. The first number is the timestamp. The second number is the X position of the event. The third number is the Y position of the event. The fourth number represents the polarity of the event (positive or negative). num_events : int number of the polarity events available in the packet.","title":"Serial Device"},{"location":"serial-device/#serialdevice","text":"pyaer . device . SerialDevice () Base class for serial devices. The base class for devices that use the serial port. eDVS is the only current supported device in this family.","title":"SerialDevice"},{"location":"serial-device/#open","text":"open ( device_type , device_id = 1 , serial_port_name = '/dev/ttyUSB0' , serial_baud_rate = 12000000 ) Open USB deivce. Arguments device_type : int Device type: libcaer.CAER_DEVICE_DVS128 , libcaer.CAER_DEVICE_EDVS , libcaer.CAER_DEVICE_DAVIS , libcaer.CAER_DEVICE_DAVIS_FX2 , libcaer.CAER_DEVICE_DAVIS_FX3 , libcaer.CAER_DEVICE_DAVIS_RPI , libcaer.CAER_DEVICE_DYNAPSE . device_id : int a unique ID to identify the device from others. Will be used as the source for EventPackets being generate from its data. default is 1 . serial_port_name : str name of the serial port device to open. default is /dev/ttyUSB0 serial_baud_rate : uint32_t baud-rate for serial port communication. default is 12M","title":"open"},{"location":"serial-device/#data_start","text":"data_start () Start data transmission. Returns flag : bool Return True if the data transmission is initialized successfully. Otherwise False .","title":"data_start"},{"location":"serial-device/#data_stop","text":"data_stop () Stop data transmission. This method stops the data transmission only. Note that this method does not destroy the respective device handle .","title":"data_stop"},{"location":"serial-device/#close","text":"close () Close USB device. This method closes an opened USB device if the respective handle is not None.","title":"close"},{"location":"serial-device/#shutdown","text":"shutdown () Shutdown device. This method is a combination of data_stop and close . This is a preferred way of shutting down a device.","title":"shutdown"},{"location":"serial-device/#send_default_config","text":"send_default_config () Send default configuration. Each type of devices has a set of default configurations (e.g. bias) that are pre-defined in the libcaer library. Note that the default configuration might not be suitable for your needs. Returns flag : bool return True if the default config is set successfully, False otherwise.","title":"send_default_config"},{"location":"serial-device/#set_data_exchange_blocking","text":"set_data_exchange_blocking ( exchange_blocking = True ) Set data exchange blocking. Arguments exchange_blocking : bool whether to start all the data producer modules on the device (DVS, APS, Mux, ...) automatically when starting the data transfer thread with caerDeviceDataStart() or not. If disabled, be aware you will have to start the right modules manually, which can be useful if you need precise control over which ones are running at any time. The default is True .","title":"set_data_exchange_blocking"},{"location":"serial-device/#set_config","text":"set_config ( mod_addr , param_addr , param ) Set configuration. The main function of setting configurations (e.g., bias). Arguments mod_addr : int a module address, used to specify which configuration module one wants to update. Negative addresses are used for host-side configuration, while positive addresses (including zero) are used for device-side configuration. param_addr : int a parameter address, to select a specific parameter to update from this particular configuration module. Only positive numbers (including zero) are allowed. param : int or bool a configuration parameter's new value. Returns flag : bool returns True if the config is set successfully, False otherwise.","title":"set_config"},{"location":"serial-device/#get_config","text":"get_config ( mod_addr , param_addr ) Get Configuration. Arguments mod_addr : int a module address, used to specify which configuration module one wants to update. Negative addresses are used for host-side configuration, while positive addresses (including zero) are used for device-side configuration. param_addr : int a parameter address, to select a specific parameter to update from this particular configuration module. Only positive numbers (including zero) are allowed. Returns param : int or bool a configuration parameter's new value. Returns None if the handle is not valid.","title":"get_config"},{"location":"serial-device/#get_event","text":"get_event () Get Event. This abstract method should be implemented in all derived classes. This method returns a packet of events according to the type of the sensor.","title":"get_event"},{"location":"serial-device/#get_packet_container","text":"get_packet_container () Get event packet container. Returns packet_container : caerEventPacketContainer a container that consists of event packets. packet_number : int number of event packet in the container.","title":"get_packet_container"},{"location":"serial-device/#get_packet_header","text":"get_packet_header ( packet_container , idx ) Get a single packet header. Arguments packet_container : caerEventPacketContainer the event packet container idx : int the index of the packet header Returns packet_header : caerEventPacketHeader the header that represents a event packet packet_type : caerEventPacketType the type of the event packet","title":"get_packet_header"},{"location":"serial-device/#get_polarity_event","text":"get_polarity_event ( packet_header ) Get a packet of polarity event. Arguments packet_header : caerEventPacketHeader the header that represents a event packet Returns events : numpy.ndarray a 2-D array that has the shape of (N, 4) where N is the number of events in the event packet. Each row in the array represents a single polarity event. The first number is the timestamp. The second number is the X position of the event. The third number is the Y position of the event. The fourth number represents the polarity of the event (positive or negative). num_events : int number of the polarity events available in the packet.","title":"get_polarity_event"},{"location":"usb-device/","text":"[source] USBDevice pyaer . device . USBDevice () Base class for all USB devices. This class is the base of DVS128, DAVIS240, DAVIS346 and DYNAPSE. open open ( device_type , device_id = 1 , bus_number_restrict = 0 , dev_address_restrict = 0 , serial_number = '' ) Open USB deivce. Arguments device_type : int Device type: libcaer.CAER_DEVICE_DVS128 , libcaer.CAER_DEVICE_EDVS , libcaer.CAER_DEVICE_DAVIS , libcaer.CAER_DEVICE_DAVIS_FX2 , libcaer.CAER_DEVICE_DAVIS_FX3 , libcaer.CAER_DEVICE_DAVIS_RPI , libcaer.CAER_DEVICE_DYNAPSE . device_id : int a unique ID to identify the device from others. Will be used as the source for EventPackets being generate from its data. default is 1 . bus_number_restrict : int restrict the search for viable devices to only this USB bus number. default is 0 . dev_address_restrict : int restrict the search for viable devices to only this USB device address. default is 0 . serial_number : str restrict the search for viable devices to only devices which do possess the given Serial Number in their USB SerialNumber descriptor. default is \"\" data_start data_start () Start data transmission. Returns flag : bool Return True if the data transmission is initialized successfully. Otherwise False . data_stop data_stop () Stop data transmission. This method stops the data transmission only. Note that this method does not destroy the respective device handle . close close () Close USB device. This method closes an opened USB device if the respective handle is not None. shutdown shutdown () Shutdown device. This method is a combination of data_stop and close . This is a preferred way of shutting down a device. obtain_device_info obtain_device_info ( handle ) Obtain device handle. This abstract method should be implemented in all derived classes. This method collects the general information about the USB device such as the width and height of the camera or the serial number of the device. Arguments handle : caerDeviceHandle a valid device handle that can be used with the other libcaer functions, or None on error. send_default_config send_default_config () Send default configuration. Each type of devices has a set of default configurations (e.g. bias) that are pre-defined in the libcaer library. Note that the default configuration might not be suitable for your needs. Returns flag : bool return True if the default config is set successfully, False otherwise. set_data_exchange_blocking set_data_exchange_blocking ( exchange_blocking = True ) Set data exchange blocking. Arguments exchange_blocking : bool whether to start all the data producer modules on the device (DVS, APS, Mux, ...) automatically when starting the data transfer thread with caerDeviceDataStart() or not. If disabled, be aware you will have to start the right modules manually, which can be useful if you need precise control over which ones are running at any time. The default is True . set_config set_config ( mod_addr , param_addr , param ) Set configuration. The main function of setting configurations (e.g., bias). Arguments mod_addr : int a module address, used to specify which configuration module one wants to update. Negative addresses are used for host-side configuration, while positive addresses (including zero) are used for device-side configuration. param_addr : int a parameter address, to select a specific parameter to update from this particular configuration module. Only positive numbers (including zero) are allowed. param : int or bool a configuration parameter's new value. Returns flag : bool returns True if the config is set successfully, False otherwise. get_config get_config ( mod_addr , param_addr ) Get Configuration. Arguments mod_addr : int a module address, used to specify which configuration module one wants to update. Negative addresses are used for host-side configuration, while positive addresses (including zero) are used for device-side configuration. param_addr : int a parameter address, to select a specific parameter to update from this particular configuration module. Only positive numbers (including zero) are allowed. Returns param : int or bool a configuration parameter's new value. Returns None if the handle is not valid. get_event get_event () Get Event. This abstract method should be implemented in all derived classes. This method returns a packet of events according to the type of the sensor. get_packet_container get_packet_container () Get event packet container. Returns packet_container : caerEventPacketContainer a container that consists of event packets. packet_number : int number of event packet in the container. get_packet_header get_packet_header ( packet_container , idx ) Get a single packet header. Arguments packet_container : caerEventPacketContainer the event packet container idx : int the index of the packet header Returns packet_header : caerEventPacketHeader the header that represents a event packet packet_type : caerEventPacketType the type of the event packet get_event_packet get_event_packet ( packet_header , packet_type ) Get event packet from packet header. Arguments packet_header : caerEventPacketHeader the header that represents a event packet. packet_type : caerEventPacketType the type of the event packet, can be one of the following: libcaer.POLARITY_EVENT , libcaer.SPECIAL_EVENT , libcaer.FRAME_EVENT , libcaer.IMU6_EVENT , libcaer.SPIKE_EVENT Returns num_events : int number of events, return None if there is no events. event_packet : caerEventPacket a packet of events that are ready to be read. get_polarity_event get_polarity_event ( packet_header ) Get a packet of polarity event. Arguments packet_header : caerEventPacketHeader the header that represents a event packet Returns events : numpy.ndarray a 2-D array that has the shape of (N, 4) where N is the number of events in the event packet. Each row in the array represents a single polarity event. The first number is the timestamp. The second number is the X position of the event. The third number is the Y position of the event. The fourth number represents the polarity of the event (positive or negative). num_events : int number of the polarity events available in the packet. get_special_event get_special_event ( packet_header ) Get a packet of special event. Arguments packet_header : caerEventPacketHeader the header that represents a event packet Returns events : numpy.ndarray a 2-D array that has the shape of (N, 2) where N is the number of events in the event packet. Each row in the array represents a single special event. The first value is the timestamp of the event. The second value is the special event data. num_events : int number of the special events in the packet. get_frame_event get_frame_event ( packet_header ) Get a packet of frame event. Arguments packet_header : caerEventPacketHeader the header that represents a event packet Returns frame_mat : numpy.ndarray a 2-D array that has the shape of (height, width). The height and width of the APS frame is determined by the specific DAVIS device (e.g., DAVIS240 will have a 180x240 APS frame. frame_ts : int the APS frame timestamp. get_imu6_event get_imu6_event ( packet_header ) Get IMU6 event. Arguments packet_header : caerEventPacketHeader the header that represents a event packet Returns events : numpy.ndarray a 2-D array that has the shape of (N, 8) where N is the number of IMU6 events in the packet. Each row of the array consists a single IMU6 event. The first value is the timestamp of the event. The next three values are accelerations on the X, Y, and Z axes. The next three values are angular velocity on the X, Y and Z axes. The last value is the temperature in Celsius scale. num_events : int number of the IMU6 events. get_imu9_event get_imu9_event ( packet_header ) Get IMU9 event. Arguments packet_header : caerEventPacketHeader the header that represents a event packet Returns events : numpy.ndarray a 2-D array that has the shape of (N, 11) where N is the number of IMU9 events in the packet. Each row of the array consists a single IMU9 event. The first value is the timestamp of the event. The next three values are accelerations on the X, Y, and Z axes. The next three values are angular velocity on the X, Y and Z axes. The next three values are X, Y, Z axis compass heading. The last value is the temperature in Celsius scale. num_events : int number of the IMU9 events. get_spike_event get_spike_event ( packet_header ) Get Spike Event. Arguments packet_header : caerEventPacketHeader the header that represents a event packet Returns events : numpy.ndarray a 2-D array that has the shape of (N, 4) where N is the number of spike events in the packet. Each row of the array has a single spike event. The first value is the timestamp of the event. The second value is the neuron ID. The third value is the chip ID. The last value is the source core ID. num_events : int the number of the spike events.","title":"USB Device"},{"location":"usb-device/#usbdevice","text":"pyaer . device . USBDevice () Base class for all USB devices. This class is the base of DVS128, DAVIS240, DAVIS346 and DYNAPSE.","title":"USBDevice"},{"location":"usb-device/#open","text":"open ( device_type , device_id = 1 , bus_number_restrict = 0 , dev_address_restrict = 0 , serial_number = '' ) Open USB deivce. Arguments device_type : int Device type: libcaer.CAER_DEVICE_DVS128 , libcaer.CAER_DEVICE_EDVS , libcaer.CAER_DEVICE_DAVIS , libcaer.CAER_DEVICE_DAVIS_FX2 , libcaer.CAER_DEVICE_DAVIS_FX3 , libcaer.CAER_DEVICE_DAVIS_RPI , libcaer.CAER_DEVICE_DYNAPSE . device_id : int a unique ID to identify the device from others. Will be used as the source for EventPackets being generate from its data. default is 1 . bus_number_restrict : int restrict the search for viable devices to only this USB bus number. default is 0 . dev_address_restrict : int restrict the search for viable devices to only this USB device address. default is 0 . serial_number : str restrict the search for viable devices to only devices which do possess the given Serial Number in their USB SerialNumber descriptor. default is \"\"","title":"open"},{"location":"usb-device/#data_start","text":"data_start () Start data transmission. Returns flag : bool Return True if the data transmission is initialized successfully. Otherwise False .","title":"data_start"},{"location":"usb-device/#data_stop","text":"data_stop () Stop data transmission. This method stops the data transmission only. Note that this method does not destroy the respective device handle .","title":"data_stop"},{"location":"usb-device/#close","text":"close () Close USB device. This method closes an opened USB device if the respective handle is not None.","title":"close"},{"location":"usb-device/#shutdown","text":"shutdown () Shutdown device. This method is a combination of data_stop and close . This is a preferred way of shutting down a device.","title":"shutdown"},{"location":"usb-device/#obtain_device_info","text":"obtain_device_info ( handle ) Obtain device handle. This abstract method should be implemented in all derived classes. This method collects the general information about the USB device such as the width and height of the camera or the serial number of the device. Arguments handle : caerDeviceHandle a valid device handle that can be used with the other libcaer functions, or None on error.","title":"obtain_device_info"},{"location":"usb-device/#send_default_config","text":"send_default_config () Send default configuration. Each type of devices has a set of default configurations (e.g. bias) that are pre-defined in the libcaer library. Note that the default configuration might not be suitable for your needs. Returns flag : bool return True if the default config is set successfully, False otherwise.","title":"send_default_config"},{"location":"usb-device/#set_data_exchange_blocking","text":"set_data_exchange_blocking ( exchange_blocking = True ) Set data exchange blocking. Arguments exchange_blocking : bool whether to start all the data producer modules on the device (DVS, APS, Mux, ...) automatically when starting the data transfer thread with caerDeviceDataStart() or not. If disabled, be aware you will have to start the right modules manually, which can be useful if you need precise control over which ones are running at any time. The default is True .","title":"set_data_exchange_blocking"},{"location":"usb-device/#set_config","text":"set_config ( mod_addr , param_addr , param ) Set configuration. The main function of setting configurations (e.g., bias). Arguments mod_addr : int a module address, used to specify which configuration module one wants to update. Negative addresses are used for host-side configuration, while positive addresses (including zero) are used for device-side configuration. param_addr : int a parameter address, to select a specific parameter to update from this particular configuration module. Only positive numbers (including zero) are allowed. param : int or bool a configuration parameter's new value. Returns flag : bool returns True if the config is set successfully, False otherwise.","title":"set_config"},{"location":"usb-device/#get_config","text":"get_config ( mod_addr , param_addr ) Get Configuration. Arguments mod_addr : int a module address, used to specify which configuration module one wants to update. Negative addresses are used for host-side configuration, while positive addresses (including zero) are used for device-side configuration. param_addr : int a parameter address, to select a specific parameter to update from this particular configuration module. Only positive numbers (including zero) are allowed. Returns param : int or bool a configuration parameter's new value. Returns None if the handle is not valid.","title":"get_config"},{"location":"usb-device/#get_event","text":"get_event () Get Event. This abstract method should be implemented in all derived classes. This method returns a packet of events according to the type of the sensor.","title":"get_event"},{"location":"usb-device/#get_packet_container","text":"get_packet_container () Get event packet container. Returns packet_container : caerEventPacketContainer a container that consists of event packets. packet_number : int number of event packet in the container.","title":"get_packet_container"},{"location":"usb-device/#get_packet_header","text":"get_packet_header ( packet_container , idx ) Get a single packet header. Arguments packet_container : caerEventPacketContainer the event packet container idx : int the index of the packet header Returns packet_header : caerEventPacketHeader the header that represents a event packet packet_type : caerEventPacketType the type of the event packet","title":"get_packet_header"},{"location":"usb-device/#get_event_packet","text":"get_event_packet ( packet_header , packet_type ) Get event packet from packet header. Arguments packet_header : caerEventPacketHeader the header that represents a event packet. packet_type : caerEventPacketType the type of the event packet, can be one of the following: libcaer.POLARITY_EVENT , libcaer.SPECIAL_EVENT , libcaer.FRAME_EVENT , libcaer.IMU6_EVENT , libcaer.SPIKE_EVENT Returns num_events : int number of events, return None if there is no events. event_packet : caerEventPacket a packet of events that are ready to be read.","title":"get_event_packet"},{"location":"usb-device/#get_polarity_event","text":"get_polarity_event ( packet_header ) Get a packet of polarity event. Arguments packet_header : caerEventPacketHeader the header that represents a event packet Returns events : numpy.ndarray a 2-D array that has the shape of (N, 4) where N is the number of events in the event packet. Each row in the array represents a single polarity event. The first number is the timestamp. The second number is the X position of the event. The third number is the Y position of the event. The fourth number represents the polarity of the event (positive or negative). num_events : int number of the polarity events available in the packet.","title":"get_polarity_event"},{"location":"usb-device/#get_special_event","text":"get_special_event ( packet_header ) Get a packet of special event. Arguments packet_header : caerEventPacketHeader the header that represents a event packet Returns events : numpy.ndarray a 2-D array that has the shape of (N, 2) where N is the number of events in the event packet. Each row in the array represents a single special event. The first value is the timestamp of the event. The second value is the special event data. num_events : int number of the special events in the packet.","title":"get_special_event"},{"location":"usb-device/#get_frame_event","text":"get_frame_event ( packet_header ) Get a packet of frame event. Arguments packet_header : caerEventPacketHeader the header that represents a event packet Returns frame_mat : numpy.ndarray a 2-D array that has the shape of (height, width). The height and width of the APS frame is determined by the specific DAVIS device (e.g., DAVIS240 will have a 180x240 APS frame. frame_ts : int the APS frame timestamp.","title":"get_frame_event"},{"location":"usb-device/#get_imu6_event","text":"get_imu6_event ( packet_header ) Get IMU6 event. Arguments packet_header : caerEventPacketHeader the header that represents a event packet Returns events : numpy.ndarray a 2-D array that has the shape of (N, 8) where N is the number of IMU6 events in the packet. Each row of the array consists a single IMU6 event. The first value is the timestamp of the event. The next three values are accelerations on the X, Y, and Z axes. The next three values are angular velocity on the X, Y and Z axes. The last value is the temperature in Celsius scale. num_events : int number of the IMU6 events.","title":"get_imu6_event"},{"location":"usb-device/#get_imu9_event","text":"get_imu9_event ( packet_header ) Get IMU9 event. Arguments packet_header : caerEventPacketHeader the header that represents a event packet Returns events : numpy.ndarray a 2-D array that has the shape of (N, 11) where N is the number of IMU9 events in the packet. Each row of the array consists a single IMU9 event. The first value is the timestamp of the event. The next three values are accelerations on the X, Y, and Z axes. The next three values are angular velocity on the X, Y and Z axes. The next three values are X, Y, Z axis compass heading. The last value is the temperature in Celsius scale. num_events : int number of the IMU9 events.","title":"get_imu9_event"},{"location":"usb-device/#get_spike_event","text":"get_spike_event ( packet_header ) Get Spike Event. Arguments packet_header : caerEventPacketHeader the header that represents a event packet Returns events : numpy.ndarray a 2-D array that has the shape of (N, 4) where N is the number of spike events in the packet. Each row of the array has a single spike event. The first value is the timestamp of the event. The second value is the neuron ID. The third value is the chip ID. The last value is the source core ID. num_events : int the number of the spike events.","title":"get_spike_event"},{"location":"utils/","text":"load_json pyaer . utils . load_json ( file_path ) Load JSON string. Arguments file_path : str the absolute path to the JSON string. Returns json_obj : dict A JSON object write_json pyaer . utils . write_json ( file_path , json_obj ) Write JSON string. Arguments file_path : str the absolute path to the JSON string. json_obj : dict a dictionary Returns flag : bool True if saved successfully False otherwise load_dvs_bias pyaer . utils . load_dvs_bias ( file_path , verbose = False ) Load bias for DVS128. Arguments file_path : str ` the absolute path to the JSON string. Returns bias_obj : dict A dictionary that contains valid DVS128 bias. load_davis_bias pyaer . utils . load_davis_bias ( file_path , verbose = False ) Load DAVIS bias. TODO: to investigate bias differences between 240C and 346. Arguments file_path : str ` the absolute path to the JSON string. Returns bias_obj : dict A dictionary that contains valid DAVIS bias. load_dynapse_bias pyaer . utils . load_dynapse_bias ( file_path , verbose = False ) Load DYNAPSE bias. Arguments file_path : str ` the absolute path to the JSON string. Returns bias_obj : dict A dictionary that contains valid DYNAPSE bias. discover_devices pyaer . utils . discover_devices ( device_type , max_devices = 100 ) Automatic discover devices. Arguments device_type : int -1 - CAER_DEVICE_DISCOVER_ALL 0 - CAER_DEVICE_DVS128 1 - CAER_DEVICE_DAVIS_FX2 2 - CAER_DEVICE_DAVIS_FX3 3 - CAER_DEVICE_DYNAPSE 4 - CAER_DEVICE_DAVIS 5 - CAER_DEVICE_EDVS 6 - CAER_DEVICE_DAVIS_RPI Returns discovered_devices : numpy.ndarray a (num_devices, 3) array the first column is device type the second column is device USB bus number or serial port name for EDVS (cannot detect string, set to 0) the third column is device USB device address or serial Baud rate (if EDVS) discovered devices type with the order Note that the array has the data type uint64, please reformat the number if necessary. num_devices : int number of available devices","title":"Utils"},{"location":"utils/#load_json","text":"pyaer . utils . load_json ( file_path ) Load JSON string. Arguments file_path : str the absolute path to the JSON string. Returns json_obj : dict A JSON object","title":"load_json"},{"location":"utils/#write_json","text":"pyaer . utils . write_json ( file_path , json_obj ) Write JSON string. Arguments file_path : str the absolute path to the JSON string. json_obj : dict a dictionary Returns flag : bool True if saved successfully False otherwise","title":"write_json"},{"location":"utils/#load_dvs_bias","text":"pyaer . utils . load_dvs_bias ( file_path , verbose = False ) Load bias for DVS128. Arguments file_path : str ` the absolute path to the JSON string. Returns bias_obj : dict A dictionary that contains valid DVS128 bias.","title":"load_dvs_bias"},{"location":"utils/#load_davis_bias","text":"pyaer . utils . load_davis_bias ( file_path , verbose = False ) Load DAVIS bias. TODO: to investigate bias differences between 240C and 346. Arguments file_path : str ` the absolute path to the JSON string. Returns bias_obj : dict A dictionary that contains valid DAVIS bias.","title":"load_davis_bias"},{"location":"utils/#load_dynapse_bias","text":"pyaer . utils . load_dynapse_bias ( file_path , verbose = False ) Load DYNAPSE bias. Arguments file_path : str ` the absolute path to the JSON string. Returns bias_obj : dict A dictionary that contains valid DYNAPSE bias.","title":"load_dynapse_bias"},{"location":"utils/#discover_devices","text":"pyaer . utils . discover_devices ( device_type , max_devices = 100 ) Automatic discover devices. Arguments device_type : int -1 - CAER_DEVICE_DISCOVER_ALL 0 - CAER_DEVICE_DVS128 1 - CAER_DEVICE_DAVIS_FX2 2 - CAER_DEVICE_DAVIS_FX3 3 - CAER_DEVICE_DYNAPSE 4 - CAER_DEVICE_DAVIS 5 - CAER_DEVICE_EDVS 6 - CAER_DEVICE_DAVIS_RPI Returns discovered_devices : numpy.ndarray a (num_devices, 3) array the first column is device type the second column is device USB bus number or serial port name for EDVS (cannot detect string, set to 0) the third column is device USB device address or serial Baud rate (if EDVS) discovered devices type with the order Note that the array has the data type uint64, please reformat the number if necessary. num_devices : int number of available devices","title":"discover_devices"}]}